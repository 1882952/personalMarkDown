# 一：简介

javascript，运行在浏览器上的脚本语言，一个完整的JavaScript包括三个部分：

- ECMAscript（核心）

- 文档对象模型（DOM）

- 浏览器对象模型（BOM）

## 1：ECMAScript

web浏览器只是可能实现ECMAScript的宿主环境之一，其他的宿主环境包括Node等。

ECMAScript规定了一门编程语言的标准，比如语法、类型、语句、关键字、保留字、操作符、对象等， JavaScript实现了ECMAScript。

## 2：DOM

html结构类型于XML，是一颗树结构，文档对象模型是针对XML但经过扩展用于HTML应用程序的编程接口。 DOM把页面映射为了一个多层次的节点结构（也就是一棵DOM树），开发借助dom提供的节点操作API，可以轻松地增、删、改页面结构。

![images\DOM](images\DOM.png)

## 3：BOM

支持可以访问和操作浏览器窗口的浏览器对象模型（BOM）。

![images\BOm](images\BOm.png)

# 二：script标签

## 1：标签的位置

惯例是放在<head>标签中的，但是会造成全部的js代码被加载完成后才能执行页面显示，会产生延迟现象，所以现代的js一般放在**body标签内容的后面**，让页面先显示，然后js再慢慢加载。

## 2：延迟脚本：

在scrpit标签中的defer属性，加了这个属性表示在脚本执行时不会影响页面的构造，脚本会被延迟到页面加载解析完之后才会运行。

## 3：异步脚本

script标签中的async属性，作用与defer类似，但async只适用于外部脚本，而且标记为async的脚本并不保证按照指定的顺序运行，也就是并发的。

## js使用策略：

建议使用外部文件，优点：可维护，可缓存，适应未来。

### js显示方案

JavaScript 能够以不同方式“显示”数据：

- 使用  window.alert()  写入警告框
- 使用  document.write()  写入 HTML 输出
- 使用  innerHTML  写入 HTML 元素
- 使用  console.log()  写入浏览器控制台

# 三： js基本概念

## 1：语法：

1. 区分大小写；

2. 标识符与java相同，字母数字下划线或者$开头。

3. 严格模式：ECMA5引入了严格模式，在脚本顶部添加代码“use strict”，使用编译指示，就可严格检测代码与报错。

4. 语句：以；结尾，但是不写也能运行，建议写上。

5. js中，表达式是值，变量和运算符的组合，计算结果是值。

## 2：关键字与保留字

与java中的关键字几乎类似，比较就行。

## 3：变量定义

ECMA使用的是松散类型的变量，即动态类型的变量，在运行时会确定类型，这就与强静态类型的java有着很大的区别。 

> 定义变量为var，而默认值是undefined,这点一定要注意，java中引用类型的默认值是null。 var 变量可以用来保存任意类型的变量。

> 注意：局部变量在函数退出时就会被销毁，这点与java类型，无法在外部读取方法体中的局部变量，但是要注意闭包，如果函数的外部引用被持有，那么就可以通过这个引用去读取函数内部的内容。

### 定义全局变量

在方法体中省略了var就可以定义全局变量，但是不建议这么做，容易导致抛出引用错误。

## 4：数据类型

ECMAScript中有五种基本的数据类型,undefined,null,boolean,number和string。

还有一种复杂的数据类型---Object，Object本质上是一种无名的键值对组成的。

ECMAScript不支持**任何的自定义类型的机制**，所有的值最终都是上面这六钟数据类型之一。  因为ECMAS是动态类型的，所以也就没必要定义其他数据类型了。

>  动态语言在这一点上与静态语言完全不同，就拿java来说，在编译阶段必须有一个对应的类型，虽然有多态机制，但是还是得在运行时确定对应的类型，这个类型必须是在编译阶段已经存在的，因为Class类加载机制，通过双亲委派模型，每个类的加载都必须有对应的类加载器加载（父类加载器优先加载），这样在java中，所有的对象的父类对象为Object对象，构成了Object的体系类结构。

### typeof

判断一个变量属于什么数据类型，使用type of关键字判断。

![images\typeof](images\typeof.png)

具体用法：typeof变量名。

注意：typeof后面的可以是变量名，也可以是数值字面量， 比如typeof null ，返回的是Object，因为特殊值null被认为是一个空的对象引用。

> 在js中，函数其实是被看做一个对象的，不是一种数据类型。

#### （1）：undefined

该类型只有一个值，即undefined，在使用var声明变量，但是未对其加初始化时，这个变量的默认值就是undefined。

> 当typeof一个变量时返回undefined，说明对该变量没有初始化。

#### （2）：null类型

null值表示一个空对象的指针。

#### （3）：boolean类型

可以转为false的值，false，“”（空字符串），0，NaN，null，undefined。

剩余的都可以转为true

#### （4）：Number类型：

分为整数和浮点数

NaN，not  a number，表示一个本来要返回数值的操作数未返回数值的情况，在ECMAS中，任何数值除以0都会返回NaN。

> 首先，任何涉及NaN的操作都会返回NaN，其次，NaN与任何值都不相等，包括它本身。
> 
> 针对这两个特点，ECMA定义了isNaN()函数，功能是确定参数不是数值。

##### 数值转换

有三个函数，Number(),parseInt()和parseFloat(),把非数值转换为数值。

Number()用于任何数据类型，而后两个函数专门用于转字符串。

```javascript
 var num1=Number("Hello world"); //NaN
    var num2=Number(""); //0
    var num3=Number("00011");//11
    var num4=Number(true); //1
```

由于Number函数在处理字符串时比较复杂而且不够合理，所以更常用parseInt（）函数。该函数会忽略字符串前面的空格，直到找到第一个非空格字符，如果第一个非空格字符不是数字符号或者负号，那么就会返回NaN。

#### （5）：String

字符串类型，可以双引号也可以单引号，字符串，不可变，原理与java相同，不再深究。  将一个值转为字符串的函数是toString()，可以传参,参数可以是进制。但是，字符串在js中是基本数据类型！

#### （6）：Object类型

ECMAS对象，一组数据和功能的集合。

var a=new Object();

采用的是原型链模式，同java一样，Object类型是所有它的实例的基础，实例也就可以使用Object中的属性和方法。

![images\Object类型](images\Object类型.png)

## 5：操作符

操作符都是共通的，看一看就行，  注意== （相等）与===（全等）的区别

## 6：语句

foreach语句在js中的格式是 for（A in AList）

##### label语句：

使用label语句可以在代码中加标签，以便跳转使用，常用与循环中，个人理解类似于goto。

```javascript
start:for(var i=0;i<count;i++){
    alert(i);
}
```

上面的start就是label语句，可以在循环体中判断时跳转到开头，通常配合continue使用。

##### switch语句：

case中的条件可以是任何数据类型（六种），也可以是表达式。

## 7：函数

```javascript
function  aa(num11,num22) {

        return num11+num22;
    }
```

ECMA中不必定义返回值类型，（动态语言，必须就这六种数据类型之一），所以参数也不必定义类型。

![images\理解函数](images\理解函数.png)

ECMA中的参数在内部是用一个数组来实现的，函数接收到的永远是这个数组，而不关心数组中的参数个数，是哪些参数等。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。

```javascript
/*
* 函数中的参数调用只是传入一个数组，函数接收到的永远是这个数组，并且可以通过
* arguments对象读取这个数组。  所以就有了下面的Demo，因为传入的数组，所以不用
* 去关心数组中的参数类型，参数个数。
* */
    function sayhi() {
        alert("hello"+arguments[0]+","+arguments[1]);
    }
    function howManyArgs() {
        alert(arguments.length);
    }
    howManyArgs("string",45); //2
    howManyArgs(); //0
    howManyArgs(12); //1
```

##### 没有重载

因为ECMA函数的特性，传入的只是一个数组，并不关心具体的参数类型，所以函数就没有函数签名的特性，也就不能重载。  当有两个相同名字的函数定义时，只会造成覆盖，使用最新的函数定义。

#### 函数调用

函数中的代码将在其他代码调用该函数时执行：

- 当事件发生时（当用户点击按钮时）
- 当 JavaScript 代码调用时
- 自动的（自调用）

# 四：变量、作用域与内存问题

## 4.1 基本类型和引用类型值

基本数据类型：5种，undefined，null，number，string，boolean

引用数据类型：Object（对象）

#### 4.1.1动态属性

对于引用类型的值，可以为其添加属性和方法，也可以改变和删除其属性与方法。

```javascript
 var person=new Object();
    person.name="nac";
    alert(person.name);
    name.age=27;
    alert(name.age); //undifinded  只能给动态类型添加属性
```

首先是为person对象定义了name属性并赋值，该name是个string类型，基本数据类型，然后又给name定义了一个age属性（number）类型，但是发现age为undefined，所以说明了，动态赋值只与引用类型有关，**只能给引用类型动态地添加属性。**这点需要谨记。

#### 4.1.2 复制变量值

与java类型，复制基本数据类型的值，就是重新拷贝一份赋给引用方。

复制引用数据类型的值，默认情况下，仅仅是把堆中对应的Object对象的引用地址引用过来。 （也就是浅拷贝原理）。

#### 4.1.3 传递参数

ECMA传递参数是值传递，与java相同，基本数据类型的传入是拷贝值，引用数据类型的传入是拷贝一份引用地址，与原引用无关。（但是可通过引用地址修改堆中对象的内容，这个问题在java中的char数组与string类型的面试题已经思空见惯了，不在赘述）。

#### 4.1.4 检测类型

虽然typeof在检查基本数据类型时作用很大，但是在检测引用类型时，用处不大。

所以使用 instanceof操作符，判断对象的。

> 根据规定，所有引用类型的值都是Object实例，因此在检测一个引用类型值与Object构造函数时，instanceof操作符永远返回的是true。
> 
> 如果使用instanceof操作符检测基本数据类型，则该操作符始终返回的是false，因为基本数据类型不是对象。

## 4.2执行环境及作用域

![images\执行环境](images\执行环境.png)

阅读上面内容，可以了解到，在web浏览器中，全局执行环境是window对象（全局执行环境的变量对象），所有的全局变量和函数都是作为window的属性和方法创建的。 （通过这个变量对象的概念，也就理解了万事万物皆对象的面向对象思想设计模式，具体的来说，Vue中的Vue对象也就是基于这个原理）。

如果与java作类比的话，这个全局执行环境的变量对象，就相当于一个类创建的对象，对象再访问类里面的属性和方法。

每个函数也有一个自己的执行环境，如果把全局环境比喻为栈空间的话，每个函数的执行环境就是栈帧。 

但是在js中有一个作用域链，当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的目的是保证执行环境有权访问所有变量与函数。 

因为作用域链中的下一个对象来自外部环境，所以全局执行环境的变量始终是作用域链的最后一个对象。

```javascript
  /*
      作用域链
    * */
    var color="blue";
    function changeColor() {
        if(color=="blue"){
            color="red";
        }else {
            color="blue";
        }
    }
    changeColor();
    alert(color);
```

在这个简单的例子中，changecolor函数的作用域链包含着两个对象：自己的变量对象（其中定义着arguments对象）和全局环境的变量对象（window对象），所以在函数内部中可以访问变量color。

作用域链只能是内部的访问外部的，因为内部的持有外部的变量对象，就和java中的内部类一个道理，而外部的不能访问内部的。

#### 延长作用域链

虽然执行环境的类型总共有两种：全局和局部（函数），但是也可以通过：

- try--catch中的catch块延长

- 使用with语句，但是不推荐。

#### 没有块级作用域

在js中没有块级作用域，如果使用代码块，那么就会将变量添加到当前的执行环境中。

## 4.3 垃圾收集

这点大概看一看，原理与jvm类似，书中介绍地比较简单，  只需要记住可以在全局变量调用完后，手动解除引用，即 a=null操作来管理内存。



## 总结：

今天主要学习了js高级程序设计的前四章， 主要了解了

js的结构，ES，DOM与Bom。

script标签。

js的基本语法，动态语言，var定义变量， 六种数据类型，基本：undefined，null，number，boolean和String ，引用：Object（就是中的任何引用类型的实例值都是Object对象）。  掌握相关内容。 记住，js中只有这六种数据类型，不支持其他的自定义的数据类型。 使用typeof 判断基本数据类型，使用instanceof判断引用数据类型。

函数：函数不必定义返回值， 函数的传入实际上只是传入一个数组，数组中包含着具体的参数，所以函数不关心传入的参数个数、类型等， 函数内部有对应的argument对象来读取这个数组。   这点很重要。    因为不关心参数所以没有函数签名的特性，也就无法重载。

变量问题：动态属性，只有引用类型才能给对应的值动态地创建属性，而不能给基本数据类型动态创建属性。 复制;基本数据类型拷贝一份， 引用数据类型只复制堆中的地址引用（浅拷贝）。   传递：只有值传递，与java相同。

执行环境与作用域：即原型链， 这个概念与java中的内部类相似 ，内部的持有外部的指针。  在js中，每个执行环境都有一个对应的变量对象， 全局是window对象，定义全局变量与函数就相当于给window对象创建属性和方法，  而每个函数的调用中也会产生一个执行环境（相当于栈帧），在对应的函数中会持有外部变量对象的引用，也就能访问全局变量与方法了， 这也就是原型链的概念。 

对于js中的垃圾回收，简单了解即可，内存管理一般是在使用全局变量之后置为null即可。（局部变量不用管，同java一样，栈帧执行完之后就会释放并销毁）。









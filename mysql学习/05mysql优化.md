### 数据库的乐观锁与悲观锁

在数据库中还有一类锁，乐观锁与悲观锁。

悲观锁：对数据被外界的修改保持保守态度，因此在整个数据的处理过程中，将数据处于锁定状态（依靠数据库提供的锁机制）。

乐观锁：大多是基于数据版本（version）记录机制实现的，即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据，这与MVCC的并发事务管理机制相似。

## 一：数据库的优化

### （一）：查询性能优化

#### 1:为什么查询速度会变慢？

  偶尔会很慢的原因：

- 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘

- 执行的时候遇到锁，如表锁或者行锁。

一直很慢的原因：

- 查询了不需要的记录。

- 多表关联时返回了全部的列

- 总是取出全部列，比如select *

- 重复查询相同的数据

- 没有用索引，或者索引字段被用于表达式或者函数计算，索引无效

- 数据库选错了索引

#### 2：优化策略

##### 使用Explain进行分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

比较重要的字段有：

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

##### 优化数据的访问

1: 减少请求的数据量。

- 只返回必要的列：最好不要用select *

- 只返回必要的行，使用limit语句来限制返回数据

- 缓存重复查询的数据，将重复查询的数据放在redis等缓存数据库中。

2：减小服务器端的扫描的行数

最有效的方式是使用索引来覆盖查询。

##### 重构查询的方式

##### 1：切分大查询

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

```sql
DELETE FROM messages WHERE create < DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

```sql
rows_affected = 0
do {
    rows_affected = do_query(
    "DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")
} while rows_affected > 0
```

##### 2：分解大连接查询

将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

- 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
- 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
- 减少锁竞争；
- 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
- 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。

```sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id=tag.id
JOIN post ON tag_post.post_id=post.id
WHERE tag.tag='mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);
```



### （二）表的切分

#### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

- **垂直拆分的优点：**  可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：**  主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。

#### 水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。



水平拆分能够  **支持非常大的数据量存储，应用端改造也少**，但  **分片事务难以解决**  ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐  **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度**  ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**

- **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。**  当当网的  **Sharding-JDBC**  、阿里的TDDL是两种比较常用的实现。
- **中间件代理：**  **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。**  我们现在谈的  **Mycat**  、360的Atlas、网易的DDB等等都是这种架构的实现。

#### sharding策略

- 哈希取模：hash(key) % N；
- 范围：可以是 ID 范围也可以是时间范围；
- 映射表：使用单独的一个数据库来存储映射关系。

#### Sharding 存在的问题

##### 1. 事务问题

使用分布式事务来解决，比如 XA 接口。

##### 2. 连接

可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。

##### 3. ID 唯一性

- 使用全局唯一 ID（GUID）
- 为每个分片指定一个 ID 范围
- 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)



## mysql主从复制

### 概念

mysql主从复制是异步复制，大概过程就是让一个线程从主服务器中记录操作日志，然后从服务器I/O线程读取这个日志,重新执行一遍主服务器上的操作，保证数据一致性。

### 原理

主要涉及三个线程：binlog，IO和sql线程。

- binlog线程: 负责将主服务器上的数据写入二进制日志（Binary log）中。

- I/O线程：负责从主服务器上读取二进制日志，并写入到从服务器的中继日志（Relay log）。

- SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![images\mysqlmasterslaver](images\mysqlmasterslaver.png)

#### 如何提高Mysql主从复制的效率？

1.master 端

master端有2个参数可以控制。

Binlog_Do_DB : 设定哪些数据库需要记录Binlog。

Binlog_Ignore_DB : 设定哪些数据库不要记录Binlog。

2.slave 端

slave端有6个参数可以控制。

Replicate_Do_DB : 设定须要复制的数据库，多个DB用逗号分隔。

Replicate_Ignore_DB : 设定可以忽略的数据库。

Replicate_Do_Table : 设定须要复制的Table。

Replicate_Ignore_Table : 设定可以忽略的Table。

Replicate_Wild_Do_Table : 功能同Replicate_Do_Table，但可以带通配符来进行设置。

Replicate_Wild_Ignore_Table : 功能同Replicate_Ig-nore_Table，可带通配符设置。

### 读写分离

主服务器处理写操作以及实时性比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

![images\readwirtedivide](images\readwirtedivide.png)



## 总结

今天认识了乐观锁与悲观锁，区别是悲观锁对外界对数据的修改持保守策略（所以使用数据库中的锁保证同步）。 乐观锁采用的是数据版本记录号来作为数据的同步手段。

然后学习了mysql的优化，

查询变慢的原因，主要是记录加锁了或者查询语句写的有问题，比如全部查询（多表的全部记录），没有索引或者索引利用不当。  

优化查询：使用Explain分析，减少数据的访问量（比如只查询必要的列），尽量使用索引来覆盖字段。

重构查询：可以切分大查询，或者分解多外连接的查询。



对于表的优化，垂直分区或者水平分区。

垂直分区：将一个表，按列转变为多个表，比如把电商数据库垂直切分为商品数据库，用户数据库。 优点是，表规模减小，易于操作，性能提高。 缺点是：主键产生冗余，需要管理冗余列。

水平分区：将一个大表中的记录分割在多张结构相同的表中，但这样的缺点很多，分片事务难以解决，也难以维护，拆分后会带来各种复杂问题， 所以代替手段是采用客户端代理或者中间件代理，将分片的逻辑分在应用端。



接着学习了主从复制， 记住三个线程，binlog，i/o与sql线程，原理是：binlog线程记录主表中的数据执行并保存在二进制文件binary log中，而i/o线程的作用就是读取主表中的二进制文件记录并写入从表中的relay日志中，sql线程再去执行从表的relay日志，将主表中的操作记录再在从表中执行一遍。



读写分离：主服务器用于写和实时性很高的读，从服务器用于读操作，具体的选择策略交给代理服务器选择。

> 本篇来学习数据库的一些重要理论。

## 一：事务：

#### 概念：

事务是指满足ACID特性的一组操作，可以通过commit提交，也可以通过callback回滚。  学习事务的具体例子就是去银行存钱取钱的操作，假设取钱的操作失败了，那么取钱的这个事务也会回滚。

### ACID特性（重点）

#### 1:原子性（Atomicity） ----原子

事务被视为不可分割的最小单元，事务要么操作成功，要么失败回滚。

回滚可以用回滚日志来实现，回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 2：一致性（Consistency） ----读共享

    数据库在事务执行前后都保持一致性状态。（相当于线程同步状态，读取数据结果都是相同的）。

#### 3：隔离性（Isolation） -----写独立

一个事务所做的修改在最终提交前，对其他事务是不可见的。 （就是相当于事务的修改过程私有）。

#### 4：持久性（Durability） ----长久保存

一旦事务提交，则它所做的修改就永久保存在数据库中，即使系统发生崩溃也不会丢失。使用重做日志来保证持久性。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

### AUTOCOMMIT

mysql中采用的是自动提交。也就是说，如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

## 二：并发一致性问题：

这也是个重点，面试常考！

也分为四种：

#### （1）脏读：

比如事务A正在修改一个变量a，还未提交，由于隔离性，对其他事务不可见。而这个时候，事务b读取了这个变量a， 这个时候就产生了脏数据。

#### （2）丢失修改：

事务A读取一个数据a时，事务B也读取了这个数据a，然后事务A，B都修改这个a，最后提交到数据库，可以发现，丢失了一次修改。

#### （3）不可重复读

当事务A在多次读取同一个数据时，如果事务B对这个数据进行了修改，那么A再次读取时，就会发现与原来的读取不一样，这就是不可重复读。

#### （4）幻读

事务A读取了某个表中的几行记录，但是另一个事务B在这几行记录中又插入了一些数据记录，则事务A读取时就发现了多出来了数据，把这种现象称之为幻读。

> 可以发现，学习事务时，要把每个事务抽象为线程，要了解线程模型（主内存与工作内存模型），事务共享数据读取，但在修改数据时是独立的，就相当于把数据拷贝到自己的工作区域，修改完后再提交更新，这就做到了隔离性，修改对其他事务不可见。 但是在并发情况下，事务就会产生这四种脏读、丢失修改、不可重复读、幻读的四种情况。

为了解决这种事务的并发问题，那么就像多线程一样，加锁或者使用其他的同步手段。

## 三：封锁

为了保证同步，mysql就使用了两种粒度的锁，行级锁与表级锁。

就和线程同步一样，为了性能就需要加锁的同步区域要小，但是mysql中的记录相当于都是平权的，所以如果使用粒度比较小的锁，那么就需要在同一个区域加多个锁，

这样就加大了开销。

所以在选择锁粒度时，需要对锁开销和并发程度做一个抉择。

### 封锁类型

#### 1：读写锁

- 排它锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

> 可以通过并发包的读写锁理解，但是不同的是，写锁是独立的（读锁状态下不能加任何锁），读锁就是共享锁，可以加给多个事务，但是不能执行更新操作。  这里的读写锁是独立互斥的！

#### 2. 意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

### 封锁协议：

#### 1:三级封锁协议

> 一级封锁协议; 事务T要修改A必须加X（写）锁，直到T再释放。可以解决丢失修改的问题，因为写锁过程中，只能有一个事务获取锁。
> 
> 二级封锁协议：在一级的基础上，要求读取数据A时必须加读锁S，读完马上释放S锁，可以解决脏数据的问题，因为在修改数据时，就会加X锁，那么其他事务就不能再加S锁了，也就不会再X锁执行时获取数据。
> 
> 三级封锁协议：在二级的基础上，必须读取数据时必须加S锁，直到事务结束时才能释放锁。 这样可以解决不可重复读问题，因为事务执行的是多次读取操作，其他事务是获取X锁执行的，必须等到事务执行完毕，才能加X锁。

可以发现，三级封锁协议就与并发包中的读写锁原理相似，先获取写锁，写锁获取后才能获取读锁，而读锁可以被多个线程获取，当写锁执行写操作后，所有的读锁线程都会被阻塞，这样就完成了写锁的安全操作。  而这就是二级封锁协议的原理，三级封锁协议也不难理解，加入事务理解就行。

#### 2：两段锁协议：

加锁和解锁分为两个阶段进行，可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。 这段话的意思就相当于as-if-serial原则，不管事务的执行顺序是咋样的，只要并发执行的事务结果与某个串行执行的事务结果相同，那么就是符合的。

事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。

```html
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。

```html
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```

> 对于这两个协议，结合ReentrankReadWriteLock读写锁的原理理解应该不难，三级封锁协议就对应着 写---读----读锁释放----写锁释放的过程。 两段锁就是利用并发技术的可串行化执行。

### mySQL 隐式与显示锁定

MySQL 的 InnoDB 存储引擎采用**两段锁协议**，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

## 四：隔离级别

对于并发事务执行出现的四种情况以及mysql中采用的封锁协议，mysql采用了四种隔离级别。

### 未提交读（Read UNCOMMITED）

事务中的修改，即使是没有提交，也是对其他事务可见的；解决了丢失修改的问题。

### 提交读（READ COMMITED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。   解决了脏读的问题。

### 可重复读（REPEATABLE READ）

保证在同一个事务多次读取时结果是相同的，解决了不可重复读的问题。

### 可串行化（SERIALIZABLE）

强制事务串行执行

需要加锁实现，而其它隔离级别通常不需要。

---

| 隔离级别 | 脏读  | 不可重复读 | 幻影读 |
|:----:|:---:|:-----:|:---:|
| 未提交读 | √   | √     | √   |
| 提交读  | ×   | √     | √   |
| 可重复读 | ×   | ×     | √   |
| 可串行化 | ×   | ×     | ×   |

## 五、Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙，是一个前开后闭区间。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +supremum)
```

## 六：关系型数据库设计理论

### 函数依赖

记 A->B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。

如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。

对于 A->B，如果能找到 A 的真子集 A'，使得 A'-> B，那么 A->B 就是部分函数依赖，否则就是完全函数依赖。

对于 A->B，B->C，则 A->C 是一个传递函数依赖。

### 异常

以下的学生课程关系的函数依赖为 {Sno, Cname} -> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno | Sname | Sdept | Mname | Cname | Grade |
|:---:|:-----:|:-----:|:-----:|:-----:|:-----:|
| 1   | 学生-1  | 学院-1  | 院长-1  | 课程-1  | 90    |
| 2   | 学生-2  | 学院-2  | 院长-2  | 课程-2  | 80    |
| 2   | 学生-2  | 学院-2  | 院长-2  | 课程-1  | 100   |
| 3   | 学生-3  | 学院-2  | 院长-2  | 课程-2  | 95    |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如  `学生-2`  出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了  `课程-1`  需要删除第一行和第三行，那么  `学生-1`  的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

所以就需要符合三种范式的设计规则,范式的提出就是为了解决上述的四种异常。

### 1：第一范式（1NF）

属性不可分割。

### 2：第二范式（2NF）

每个非主属性的函数完全依赖于键码。 也就是说，在设计一个表时，必须有对应的主键。 比如将学生编号sno作为主键，让学生分数grade依赖于sno。

### 3：第三范式（3NF）

非主属性不传递函数依赖于键码。  简单表现就是，非主键的字段不能作为其他表中字段的依赖，只有主键才能作为另一个表中某元素的依赖，也就是外键。   这也就是外键字段的删除原因，先删除从表中的外键字段属性，删除光了才能删除主表中的作为主键的字段。

> 所以，对于范式的学习，应该学习这种函数的依赖关系，把表中的字段想象为一个单链表， A-->B--->C---->D ,假设有这么四个字段，那么就让链表头A做主键最合适，因为BCD字段都能靠A找到。
> 
> 那么外键呢，就相当于另一个链表想要利用这个链表的属性，那么，是不是选择这个链表的主键也就是头结点更合适，当前，在这个例子中，假设A作为了外键， 那么如果不删除其他链表中对应的引用（也就是外键属性），那么这个A对应的字段也就无法删除。

## 七、ER 图

Entity-Relationship，有三个组成部分：实体、属性、联系。

用来进行关系型数据库系统的概念设计。

## 实体的三种联系

包含一对一，一对多，多对多三种。

- 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；
- 如果是一对一，画两个带箭头的线段；
- 如果是多对多，画两个不带箭头的线段。

## 总结：

本篇学习了事务， 首先，事务的四个特性，原子性、一致性、隔离性、持久性，这四个特性一定要记清楚。

    然后并发中事务出现的四个问题： 丢失修改（两个事务同时修改A）、脏读（一个事务修改了a还未提交，另一个事务刚好读取了a）、不可重复读（事务多次读取a，但是另一个事务修改了a，导致事务再次读取时就发现a变了）、幻读（一个事务读取了某区域的一些记录，然后另一个事务又在这个区域中插入了某些数据，再次读取时，那么就发生了幻读）。  
    
    为了解决这四个并发问题，那就得加锁，mysql中采用了表级锁与行级锁，实际上采用了封锁技术（封装锁的技术）， 本质上采用的读锁与写锁， 然后也采用了意向锁。  通过三级封锁协议与两段锁协议解决了这四个并发问题（这两个协议也不难理解，只要掌握了并发包下lock中的读写锁运行机制，写锁---读锁----读锁释放----写锁释放的过程，很容易理解）。
    
    mysql中的innoDB采用的是两段锁协议，需要时才加锁。然后基于这两个协议，mysql设置了四种隔离级别， 未提交读，提交读，可重复读，可串行化，分别解决了丢失修改，脏读，不可重复读，幻读的问题。    
    
    在innodb中，还采用了三种锁，

- 单行记录锁Record Locks

- 行与行之间的间隙锁Gap Locks

- Next-Key Locks ，record+gap锁的合并， 个人把它简称为区块锁。

然后就是三种范式了，这个知识点也很重要， 范式主要是用来解决设计表不规则产生的四种问题，数据沉余（完全相同的两条记录），修改异常，插入异常，删除异常。

 为了解决，就出现了范式，

第一范式：属性不可分割且是独立单元。

第二范式：每个非主属性函数需依赖键值。具体来说就是一个表需要主键。

第三范式：只有作为键值的属性才能作为外部函数的依赖，具体来说就是主键才能作为其他中的外键。 

理解范式，就配合单链表理解，链表头头结点就是主键， 而且头结点可以作为其他链表中的节点（外键）而不影响各个表中的关系，也就很容易理解，为什么要删除从表中的相关信息，才能删除主键字段的相关信息。



## 八：MVCC多版本并发控制

mvcc（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，它是用于实现提交读和可重复读这两种隔离级别。

而未提交读隔离级别总是读取最新的数据，无须使用MVCC。 可串行化隔离级别需要对所有的读取的行都需要加锁，单纯使用MVCC无法实现。

### 版本号

- 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号：事务开始时的系统版本号。

InnoDB的每行记录后面都保存着两个隐藏的列，用来存储两个版本号：

- 创建版本号：指示创建一个数据行的快照时的系统版本号；
- 删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。

#### Undo日志

Innodb的mvcc使用的快照存储在Undo日志中，该日志通过回滚指针把一个数据行的所有快照连接起来。（就是类似于git版本库的结构）。

![images\undoMvcc](images\undoMvcc.jpg)

> 到这其实应该理解了mvcc怎么支持并发控制，利用了版本号，每条记录的生成与改变都是对应着版本号的，然后将对应的数据用快照保存起来到对应的版本号中，存储在Undo日志中。读取与写入都需要按照策略选取对应的版本号数据。

实现过程：

以下针对可重复读的隔离级别：

#### 1:SELECT

该操作保证多个事务读取的是同一个数据行的快照，这个快照是最近的一个有效快照。

但也有例外，如果一个事务正在修改该数据行，那么它可以读取事务本身做的修改，而不用和其他事务读取的结果一致。

当开始一个新的事务时，该事务的版本号肯定会大于所有数据行快照的创建版本号。

把没对一个数据行做修改的事务称为 T1，T1  所要读取的数据行快照的创建版本号必须小于当前事务的版本号，因为如果大于或者等于当前事务的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。

除了上面的要求，T1  所要读取的数据行快照的删除版本号必须大于当前事务版本号，因为如果小于等于当前事务版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。

#### 2. INSERT

将系统版本号作为数据行快照的创建版本号。

#### 3. DELETE

将系统版本号作为数据行快照的删除版本号。

#### 4. UPDATE

将系统版本号作为更新后的数据行快照的创建版本号，同时将系统版本号作为作为更新前的数据行快照的删除版本号。可以理解为新执行 DELETE 后执行 INSERT。

## 快照读与当前读

快照读读指的是读取快照中的数据，而当前读指的是读取最新的数据。

当前读：

1. `select  *  from table ....;`

快照读：

1. `select  *  from table where  ?  lock  in share mode;`
2. `select  *  from table where  ?  for update;`
3. `insert;`
4. `update ;`
5. `delete;`

引入当前读的目的主要是为了免去加锁操作带来的性能开销，但是快照读需要加锁。



> MVCC采用了版本号的方式控制并发， 每当开始一个新的事务，系统的版本号就会递增， 而这个新的事务的版本号就是事务开始时的系统版本号。
> 
> innodb中的每行记录中都保存着两条记录：
> 
> 创建版本号（创建数据时保存快照的版本号），记录数据何时创建，每当创建或者更改数据时，都会创建一个新的快照用系统版本号保存。
> 
> 删除版本号（保存这个快照删除的版本号），记录数据何时过期，如果这个版本号大于当前事务的版本号，则表示该快照有效， 否则就证明了该快照已经被删除。

   而在每个查询操作时，必需去检查每行数据的版本号是不是和当前事务的版本号相同。 然后就是利用系统版本号与事务版本号的关系，对数据行进行相应的增删查改。

比如可重复读中， 在select操作中，所有的事务读的都是同一个创建版本号中的最新快照， 当有一个事务修改数据时也没关系，因为读的是快照，事务修改的数据会生成新的快照（必须要等到其他事务读完之后才能更新创建版本号的最新快照），但是与前面事务读的快照没有关联。 这就保证了事务的可重复读特性。

   理解了查操作，增删改操作也就容易理解了， 增：创建新的数据行，将系统版本号作为创建版本号；  删：删除当前行，那么就将当前系统版本号设为为删除版本号，作为删除文件快照链中的删除点（而这个删除点之后的快照将会无效）。  改：将系统版本号作为更新后的数据行快照的创建版本号，同时将系统版本号作为作为更新前的数据行快照的删除版本号。 改之后的，删除版本号之后的快照节点都将无效。

    当前读：读取的是最新的数据，快照读，读取的是快照中的数据。



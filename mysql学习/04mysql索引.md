## 一：mysql存储引擎

### Innodb

- InnoDb是mysql默认的存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。

- 采用了MVCC来支持高并发，并实现了四个事务隔离级别。

- 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。

- 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等。

- 通过一些机制和工具支持真正的热备份。

### MyISAM

- MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等。但 MyISAM 不支持事务和行级锁，而且崩溃后无法安全恢复。

- 只能对整张表加锁，而不是针对行。

- 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

- 可以包含动态或者静态的行。

- 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

- 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。

- 对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。

- MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。



### 比较

1. 事务：InnoDB 是事务型的。
2. 备份：InnoDB 支持在线热备份。
3. 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
4. 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
5. 其它特性：MyISAM 支持全文索引，地理空间索引。



## 二：索引

了解了mysql的存储引擎之后，其中Innodb的原理MVCC在上一篇已经分析过了，也就不再赘述。 接下来，就来学习索引。

### mysql中的基本存储结构

基本的存储结构是页（oracle的基本存储结构是元数据），页的图形如下：

![images\Innodb](images\Innodb.png)



- 各个数据页会组成一个双向链表，而每个数据页的记录又可以组成一个单向的链表。

- 在每个数据页中，都会为它里面的记录生成一个页目录，在通过主键查找时，就可以利用页目录使用**二分快速定位**到对应的位置，遍历该位置对应的分组就可以得到记录。
  
  - 而单以其他列作为查询条件，只能从最小记录开始依次遍历单链表中的每条记录。

所以说，如果我们写`select * from user where username = 'Java'`这样没有进行任何优化的sql语句，默认会这样做：

- 定位到记录所在的页（利用双链表）。

- 然后从记录所在的页中依靠单链表依次遍历。

很明显，这样先依次找到对应的页，再从页中的数据链头部依次遍历到所在的元素的位置，在表中数据量很大的情况下，很浪费时间。

        所以，这就需要索引。

### 什么是索引？

索引是在存储引擎中实现的，而不是在服务器中实现的，所以不同的存储引擎定义着不同的索引类型和实现。

    对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用**分区技术**。

#### <一>索引分类

#### 1；B+Tree索引

![images\B+tree](images\B+tree.jpg)



B+树索引是大多数存储引擎中的默认的索引类型，所以，在将数据表中相关的字段添加为索引后，那么这个字段的内容就会排序构成一个B+索引树，所以在搜索时，不需要对全盘扫描，只需要查找这里对应字段构成的B+树，就可以快速定位到记录。

- 可以指定多个列（字段）作为索引列，多个索引列共同组成键（联合索引的操作）。B+树索引适用于全键值、键值范围和键前缀查找，其中，键前缀查找只适用于最左匹配原则。

- B+树除了用于索引，还可以用于分组与排序。

- 如果不是按照索引列的顺序进行查找，则无法使用索引。

#### 2：hash索引

基于hash表实现，优点是查找非常快。在 MySQL 中只有 Memory 引擎显式支持哈希索引。

InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

限制：

- 哈希索引只包含hash值与行指针，而不存储字段（因为是将对应的字段作为keyhash化）；

- 无法用于分组与排序，只能用于精确查找。

- 如果hash冲突很多，那么查找速度就会变快。

- 不支持最左匹配原则

#### 3：空间索引

MyISAM 存储引擎支持空间索引，可以用于地理数据存储。

空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

#### 4：全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。

使用 MATCH AGAINST，而不是普通的 WHERE。



### <二>索引优点:

- 大大减少了服务器需要扫描的数据量；

- 帮助服务器避免进行排序和创建临时表；

- 将随机 I/O 变为顺序 I/O。

### <三>索引优化：

#### (1)独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则就无法使用索引。  

例如下面的查询不能使用 actor_id 列的索引：  （问题是将索引列计算了）

1. `SELECT actor_id FROM sakila.actor WHERE actor_id +  1  =  5;`

#### （2）前缀索引

比如对于BLOB，TEXT和VARCHAR类型的列，由于类型较大，必须使用前缀索引，也就是只索引部分字符。

对于前缀长度的选取需要根据 **索引选择性** 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1，此时每个记录都有唯一的索引与其对应。

#### （3）多列索引（联合索引）

在需要多个条件进行查询时，使用多列索引比使用多个单列索引的性能要好。

例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

1. `SELECT film_id, actor_ id FROM sakila.film_actor`
2. `WhERE actor_id =  1 AND film_id =  1;`

#### （4）索引的顺序

让选择性最强的索引列放在前面，这样选择性最强的索引就可以优先选择。



> 索引的最左匹配原则：
> 
> 在多列索引也就是联合索引中，索引只能查找key是否存在（相等），而在遇到范围查询时（>,<,between,like ，左匹配）等就不能再进一步匹配了。
> 
> 因此列的排序顺序决定了可命中索引的列数。
> 
> 例子：
> 
> - 如有索引`(a, b, c, d)`，查询条件`a = 1 and b = 2 and c > 3 and d = 4`，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是**相等**的情况，不能是范围匹配)

#### （5）聚簇索引

这是一种存储数据的方式

![images\聚簇索引](images\聚簇索引.jpg)



“聚簇”表示数据行与相邻的键值紧密地结合在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。

因为无法把数据存放在其他地方，所以一个表只有一个聚簇索引！

**优点**

1. 可以把相关数据保存在一起，减少 I/O 操作；
2. 因为数据保存在 B-Tree 中，因此数据访问更快。

**缺点**

1. 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。
2. 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。
3. 更新操作代价很高，因为每个被更新的行都会移动到新的位置。
4. 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。
5. 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。

##### 聚簇索引与非聚簇索引

InnoDB默认使用聚簇索引，是通过主键来聚集数据，也就是说，聚簇索引引用的列是主键。它是在叶子节点上存储了对应的数据。 其实也比较容易理解， 将链表的链表头设为索引更容易保存整条链。 

非聚簇索引是二级索引，在二级索引的叶子节点上包含了引用行上的主键列，即在叶子节点上只存储了主键和索引列。  二级索引的访问需要进行两次索引查找（原因是二级索引中只保存了“行指针”，还需要通过这个指针再次找到对应的记录的物理地址）。



#### （6）覆盖索引

索引中包含着所有的需要查询字段的值。

优点：

1. 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。
2. 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
3. 对于 InnoDB 引擎，若二级索引能够覆盖查询，则无需访问聚簇索引。



#### （7）=，in的自动优化顺序

**不需要考虑=、in等的顺序**，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。



### <四>索引tips：

- 最左前缀匹配原则（很重要，索引会一直向右进行匹配，直到遇到范围查询（>,<,between,like）就停止匹配）。

- 尽量选取区分度高的列作为索引，且让选择性最强的索引列放在前面。（区分度的公式是 `COUNT(DISTINCT col) / COUNT(*)`。表示字段不重复的比率，比率越大我们扫描的记录数就越少。）

- 索引只能是索引，即独立的列，不能使用索引列作为表达式的一部分或者作为函数的参数参与计算，这样就无法使用索引。

- 尽可能扩展索引，不要建立新的索引，即尽可以添加创建联合索引，而不是使用多个单列索引。

- 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，**MySQL只能使用一个索引**，会从多个单列索引中选择一个限制最为严格的索引。



## 总结：

本篇主要学习了数据库中的索引， 先是了解了mysql默认的引擎InnoDb与MyISAM的特点与区别，主要以Innodb的知识点为主。

    mysql中的基本结构是页，每页相当于一个双端链表的节点，然后整个表中的数据构成一条双端链表， 而每页中的记录又可以构成一个单向链表。  innodb默认使用的是聚簇索引（利用主键构成B+树并将记录保存在叶子节点中），所以在mysql中，通过主键查询就默认使用的是索引查找，这样就可以进行二分查找定位所在记录。

    而不使用主键，则在一般情况下，就会先遍历双端链表找到所在也，然后遍历单链表找到对应记录，这样在记录量很大的情况下就会很慢。

    然后就是学习了索引， 个人理解，如果把表抽象为一个value的话，那么索引就是从value中选出有代表特征的值作为key， 这样理解起来，对于索引的知识点也就能一步步理解了。  学习了索引的类型，主要以B+索引与哈希索引的知识点为主，   索引适合一定容量下的表记录，如表记录太大了，那么就需要考虑分库分表的技术。

    需要掌握索引的优化，只能是独立列作为索引（并且这个列在查询时不能进行其他表达式或计算操作），大数据类型使用前缀索引，多个列可以使用联合索引（多个列构成的一个索引），索引的顺序（比如最左匹配原则，遇到匹配范围则不再往右匹配），聚簇索引（使用主键构成的B+树索引，将对应记录保存在叶子节点中）和非聚簇索引（二级索引，叶子节点保存的是主键与索引列）。 覆盖索引：索引中包含着所需要查找的所有字段。



# 类文件结构

## jvm “无关性”

谈论 JVM 的无关性，主要有以下两个：    

* 平台无关性：任何操作系统都能运行 Java 代码  
* 语言无关性： JVM 能运行除 Java 以外的其他代码  

Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。  

JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。  

> Java 语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的， 因此字节码命令所能提供的语义描述能力肯定会比 Java 语言本身更加强大。 因此，有一些 Java 语言本身无法有效支持的语言特性，不代表字节码本身无法有效支持。



## class文件结构

class文件是二进制文件，它的内容是严格规范的，文件中没有任何空格，全是连续的0/1。<br>class文件中的所有内容被分为两部分：

- 无符号数：无符号数表示 Class 文件中的值，这些值没有任何类型，但有不同的长度。u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数。

- 表：由多个无符号数或者其他表作为数据项构成的符合数据类型。

今天主要学习的也就是表的内容。



class文件具体由以下几个构成。

- 魔数

- 版本信息

- 常量池

- 访问标志

- 类索引、父类索引、接口索引的集合

- 字段表集合

- 方法表集合

- 属性表集合

现在，就来依次了解这些结构。



### 1：魔数：

每个class文件的头四个字节称之为魔数，它的唯一作用是确定这个文件是否为一个能被jvm接受的Class文件。

Class 文件的魔数是用 16 进制表示的“CAFE BABE”，魔数相当于文件后缀名，只不过后缀名容易被修改，不安全，因此在 Class 文件中标识文件类型比较合适。



### 2：版本信息

紧接着魔数的 4 个字节是版本信息，5-6 字节表示次版本号，7-8 字节表示主版本号，它们表示当前 Class 文件中使用的是哪个版本的 JDK。  

高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必需拒绝执行超过其版本号的 Class 文件。



### 3: 常量池

常量池可以理解为clas文件的资源仓库，其主要存放两大类常量：字面量和符号引用。

- 字面量：各种文本字符串 和 final修饰的常量等。

- 符号引用：类和接口的全限定名，字段和方法的名称和描述符。

> jvm加载CLass文件的时候是进行动态链接的。也就是说，在Class文件中不会保存各个方法、字段最终的内存信息，因为这些字段或者方法的符号引用不经过运行期转换是无法得到内存的真正入口地址。  当jvm运行时，需要从常量池获取到相应的符号引用，再在类加载时或者运行时解析、翻译到具体的内存地址之中。



#### 常量池的特点

* 常量池中常量数量不固定，因此常量池开头放置一个 u2 类型的无符号数，用来存储当前常量池的容量。  
* 常量池的每一项常量都是一个表，表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。

#### 常量池中的常量类型

| 类型                               | tag | 描述          |
| -------------------------------- | --- | ----------- |
| CONSTANT_utf8_info               | 1   | UTF-8编码的字符串 |
| CONSTANT_Integer_info            | 3   | 整型字面量       |
| CONSTANT_Float_info              | 4   | 浮点型字面量      |
| CONSTANT_Long_info               | 5   | 长整型字面量      |
| CONSTANT_Double_info             | 6   | 双精度浮点型字面量   |
| CONSTANT_Class_info              | 7   | 类或接口的符号引用   |
| CONSTANT_String_info             | 8   | 字符串类型字面量    |
| CONSTANT_Fieldref_info           | 9   | 字段的符号引用     |
| CONSTANT_Methodref_info          | 10  | 类中方法的符号引用   |
| CONSTANT_InterfaceMethodref_info | 11  | 接口中方法的符号引用  |
| CONSTANT_NameAndType_info        | 12  | 字段或方法的符号引用  |
| CONSTANT_MethodHandle_info       | 15  | 表示方法句柄      |
| CONSTANT_MethodType_info         | 16  | 标识方法类型      |
| CONSTANT_InvokeDynamic_info      | 18  | 表示一个动态方法调用点 |

对于 CONSTANT\_Class\_info（此类型的常量代表一个类或者接口的符号引用），它的二维表结构如下：  

| 类型  | 名称          | 数量  |
| --- | ----------- | --- |
| u1  | tag         | 1   |
| u2  | name\_index | 1   |

tag 是标志位，用于区分常量类型；name\_index 是一个索引值，它指向常量池中一个 CONSTANT\_Utf8\_info 类型常量，此常量代表这个类（或接口）的全限定名，这里 name\_index 值若为 0x0002，也即是指向了常量池中的第二项常量。  

CONSTANT\_Utf8\_info 型常量的结构如下：  

| 类型  | 名称     | 数量     |
| --- | ------ | ------ |
| u1  | tag    | 1      |
| u2  | length | 1      |
| u1  | bytes  | length |

tag 是当前常量的类型；length 表示这个字符串的长度；bytes 是这个字符串的内容（采用缩略的 UTF8 编码）



### 4:访问标志

在常量池之后紧跟的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否被 abstract/final 修饰。



#### 5：类索引，父类索引，接口索引的集合

类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定类的继承关系。<br>类索引确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于java不支持重继承，所以父类索引就只有一个，除了Object类外，每一个java类都有父类，所以父类的索引都不为0；  接口索引的集合就用于描述这个类实现了多少个接口。



类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT\_Class\_info 的类描述符常量，通过该常量总的索引值可以找到定义在 CONSTANT\_Utf8\_info 类型的常量中的全限定名字符串。



#### 6:字段表集合：

字段表用于描述接口或者类中声明的变量，字段包含类级变量以及实例集变量，但是不包括方法内部声明的局部变量。<br>每一个字段表只表示一个成员变量，本类中的所有成员变量构成了字段表集合。字段表结构如下：

| 类型  | 名称                | 数量                | 说明                                                    |
| --- | ----------------- | ----------------- | ----------------------------------------------------- |
| u2  | access\_flags     | 1                 | 字段的访问标志，与类稍有不同                                        |
| u2  | name\_index       | 1                 | 字段名字的索引                                               |
| u2  | descriptor\_index | 1                 | 描述符，用于描述字段的数据类型。 基本数据类型用大写字母表示； 对象类型用“L 对象类型的全限定名”表示。 |
| u2  | attributes\_count | 1                 | 属性表集合的长度                                              |
| u2  | attributes        | attributes\_count | 属性表集合，用于存放属性的额外信息，如属性的值。                              |

> 字段表集合中不会出现从父类（或接口）中继承而来的字段，但有可能出现原本 Java 代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。



#### 7:方法表集合

方法表结构和字段表类似，依次包括访问标志、名称索引、描述符索引、属性表集合几项。

volatile 关键字 和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC\_VOLATILE 和 ACC\_TRANSIENT 标志。  

方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。

与字段表类似，如果父类的方法没有被子类重写，那么方法表集合中就不会出现来自父类的方法信息。 但是同样的，有可能会出现编译器自动添加的方法，最典型的就是类构造器和实例构造器。

返回值不一样对重载无效的原因：返回值的不同不会包含在重载的方法的特征签名中。



#### 8：属性表集合

属性表已经在前面出现过数次，在Class文件、字段表、方法表中都可以携带自己的属性表集合。

每个属性对应一张属性表，属性表的结构如下：  

| 类型  | 名称                     | 数量                |
| --- |:---------------------- |:----------------- |
| u2  | attribute\_name\_index | 1                 |
| u4  | attribute\_length      | 1                 |
| u1  | info                   | attribute\_length |

下面来列举一下class文件中不同位置的属性表类型。

##### (1)Code

java程序方法体的代码在编译后，最终变成字节码指令存储在Code属性中。

Code出现在方法表属性集合之中。

> Code属性是CLass文件中最重要的一个属性，把java程序中的信息分为两部分，Code属性（存储方法区中的代码） 和元数据（包括类、字段、方法定义以及其他信息）。

#### (2 )Exceptions属性

列举方法中可能抛出的受查异常，也就是在方法描述是 throws 后的异常。

#### (3)lineNumberTable

描述java源码行号和字节码行号之间的对应关系。非必须

#### （4）LocalVariableTable

描述栈帧中局部变量表中的变量与java源码中定义变量的关系。 （也不是必须的）

#### （5）SourceFile属性

记录生成这个CLass文件的源码文件名称

#### （6）ConstantValue属性

通知虚拟机自动为静态变量赋值。只有static修饰的才能使用这项属性。

#### （7）InnerClasses属性

用于记录内部类与宿主之间的关联关系。

#### （8）Deprecated和Sythetic属性

这两个属性都属于标志类型的布尔属性。

#### （9）Signature属性

这个属性可选，用于记录泛型的签名信息。

#### （10）BootStrapMethods属性

这个属性用于保存invokedynamic指令引用的引导方法限定符。



## 总结：

本篇学习了类文件class的结构，class文件分为八个部分，

- 魔数

- 版本信息

- 常量池

- 访问标志

- 类索引、父类索引、接口索引的集合

- 字段表集合

- 方法表集合

- 属性表集合

对于这八个部分，要认识其作用，掌握常量池保存字面量和符号引用的概念（面试问题） ，区分字段表。方法表、属性表集合。



# 字节码指令

需要大致认识class文件的字节码指令，

## （1）字节码和数据类型

比如load指令， iload就是从局部变量表中将int型加入到操作数栈，其余类型以首字母类推。

## （2）加载和存储指令

加载和存储指令用于将数据从栈帧中的局部变量表和操作数栈之间来回传输。

- 将一个局部变量表加载到操作数栈： 比如iload、lload_<n>等。

- 将一个数从操作数栈存储到局部变量表中：比如 istore等。

- 将一个常量加载到操作数栈， 比如：bipush、aconst_null等。

### （3）运算指令

看书就行。

### （4）类型转换指令

在大转小范围时，比如将一个浮点值窄转换为整数类型T（T限于int或者 long）,规则如下：

- 如果浮点值是NaN，那转换结果就是int或者long型的0；

- 如果浮点值不是无穷大的话，浮点值向0舍入模式取整，获得整数值v,如果v在目标T的范围内，则转换为v；

- 否则，根据v的符号，转换为T能表示的最大或者最小正数。

### （5）对象创建与访问指令

- 创建类实例：new

- 创建数组的指令：newArray，anewArray，multianArray

- 访问类字段和实例字段：getfield,putfield,getstatic,putstatic;

- 把一个数组元素加载到操作数栈：baload、caload等。

- 将一个操作数栈的元素压入到数组中：bastore等

- 取数组长度：arraylength

- 检查类实例指令：instanceof、checkcast

### （6）操作数栈管理指令

如果操作一个普通的的栈那样，有push，pop指令，swap交换栈顶两元素指令。

### （7）控制转移指令

分为条件分支，复合条件分支，无条件分支等。

### （8） 方法调用与返回指令（重点）

- invokevirtual指令用于调用对象的实例方法，根据对象的实例类型进行分派（虚方法分派，常用于多态）；

- invokeinterface指令用于调用接口的方法，它会在运行时搜索一个实现了这个接口方法的对象，并找出合适的方法调用（如spring中的autowired注解）。

- invokespecial  用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。

- invokestatic ：用于调用类方法（static方法）

- invokedynamic：用于在运行时动态解析出调用点限定符号所引用的方法，并执行该方法，前四条调用指令的分派逻辑都固化在java虚拟机中，而这条指令的分派逻辑由用户所设定的引导方法决定的（猜测在框架中应用很多，比如spring中的注解设计，aop等）。

### （9）异常处理指令

由athrow指令实现。

#### （10）同步指令

synchronized指令由管程（monitor）指令实现。





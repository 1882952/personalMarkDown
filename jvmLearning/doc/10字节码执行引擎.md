## 概述

执行引擎是jvm中最核心的组成部分之一，执行引擎在执行java代码的时候可能会使解释执行（通过解释器将class文件翻译为本地机器能理解的二进制数据流让机器执行），或者可以编译执行（即通过即时编译器产生本地代码直接执行，相当于少了解释器这个中间商，类似于gcc）。

所有java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是结果。

## 一：运行时栈帧结构

栈帧是进行方法调用与执行的数据结构，它是jvm栈中的栈元素，当调用一个方法就会产生一个栈帧，栈帧中存储了局部变量表、操作数栈、动态链接和方法返回地址等信息，这个已经在第二章中了解过了。

在编译代码的时候，栈帧需要多大的局部变量表，需要多深的栈帧都已经确定了，并写入了方法表中的code属性中。

处于栈顶的栈帧被称为当前栈帧，也就是正在被调用的方法对应的栈帧。执行引擎运行的所有字节码指令都只针对于当前栈帧的操作。下面来分析栈帧中的具体内容：

### (1)局部变量表

是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表以变量槽（slot）为最小单位。 可以存放八种数据类型，除了6种基本的数据类型外，还有reference与returnAddress类型。

* reference类型表示一个对象实例的引用，一是从此引用中直接或者间接的查找对象在java堆中数据存放的起始地址索引，二是直接或者间接地查到到对象所属数据类型在方法区中存储的类型信息。

* returnAddress已经很少用了，它代表指向一条字节码指令的地址，原始的jvm使用这个指令进行异常处理，现在已经被异常表所代替。<br>对于64位的数据，比如double，jvm会以高位对齐的方式为其分配两个连续的空间。但是局部变量表创建在线程的堆栈上，属于私有数据，所以不会出现线程安全问题。

> 谨慎注意局部变量表中的slot复用问题，如果slot没有被复用，则jvm会判断原引用仍然在使用，所以就不会gc；
> 
> 局部变量不同与全局变量，比如类变量，可以在准备阶段或者初始化阶段赋初值，而局部变量表不行，必须在它被具体使用前赋初值（赋初值个人理解是相当于给这个变量开辟一个默认的存储空间），否则无法调用。

### （2）操作数栈

操作数栈的作用就是对局部变量表的数据按照调用指令进行相应的处理（将数据压入处理与弹出返回）的区域， 也就是具体进行当前方法代码块执行的工作区。

操作数栈中的元素的数据类型必须与字节码指令严格匹配。 比如int 型数据的加法，就需要iadd指令。

栈帧在设计上是相互独立的，但是经过优化，两栈帧之间可以共享局部变量表的区域。

jvm引擎：基于栈的引擎操作， 这个栈就是栈帧。

### （3）动态链接

每个栈帧都包含一个指向运行池常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用时的动态链接，这个等会再介绍（可以联想多态）。 class文件的常量池中存有大量的符号引用，这些符号引用一部分在类加载阶段或者在第一次使用时转化为直接引用，这种转化称为静态解析。另一部分在每次运行期间转化为直接引用，这部分称为动态链接。

### （4）方法返回地址

当一个方法执行完返回时，只有两种方式，第一种是执行引擎遇到任意一个方法返回的字节码指令，可能有返回值传递给上层的方法调用者。   这种就是通常的返回方式。

第二种是遇到了异常，并且这个异常没有在方法体中得到任何处理，那么方法就会返回。

无论哪种方式，都需要返回到方法被调用的位置。方法的退出过程实际上就相当于栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入到调用者栈帧的操作数栈中，调整pc计数器的值以指向调用指令的后一条指令。

## 二：方法调用

方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即确定调用的是哪个方法），暂时还不会涉及方法内部具体的运行过程。

class文件的编译过程不包含传统编译中的连接步骤，一切方法调用在class文件里面存储的都是符号引用，而不是方法在实际运行中的入口地址（相当于直接引用）。 这样设计就带来了很大的扩展性，因为jvm的解释执行特性，需要在类加载时期或者在运行期间才能确定调用方法的直接引用。

### 1：解析

上篇分析过，在类加载的解析阶段，会将一部分符号引用转变为直接引用。但是这种解析成立的前提条件是：方法在运行之前就有了一个确定的版本，而且在运行中是不可变的。 符合条件的方法的调用称为解析。

在java中，符合编译器可知，运行期不可变的方法，主要包括**静态方法和私有方法**，前者直接与类关联，后者私有在外部不可被访问。它们都适合在类加载的解析阶段进行解析。



在字节码的学习中，我们知道jvm中有五种调用方法的指令,如下:

- invokevirtual指令用于调用对象的实例方法，根据对象的实例类型进行分派（虚方法分派---（产生）多态特性，比如重载，重写）；   也就是调用所有的虚方法。

- invokeinterface指令用于调用接口的方法，它会在运行时搜索一个实现了这个接口方法的对象，并找出合适的方法调用（如spring中的autowired注解）。  

- invokespecial  用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。  

- invokestatic ：用于调用类方法（static方法）  

- invokedynamic：用于在运行时动态解析出调用点限定符号所引用的方法，并执行该方法，前四条调用指令的分派逻辑都固化在java虚拟机中，而这条指令的分派逻辑由用户所设定的引导方法决定的（猜测在框架中应用很多，比如spring中的注解设计，aop等）。

可以发现，只要能够被invokespecial和invokestatic指令调用的方法，都是可以在类加载阶段进行解析的，符合这个条件的有静态方法、私有方法、‘实例构造器、父类方法四种，这四类都是可以在类加载的解析阶段，将符号引用转换为直接引用。所以这些方法也被称为非虚方法（即可以在运行前确定类型且运行期间不可变的方法）。

其他的方法为非虚方法（但是final关键字修饰的方法除外），显而易见，非虚方法的定义就是，可以到运行期间才会被确定类型，进行调用，这样扩展性就很强。

    final关键字修饰的方法虽然也是被invokevirtual调用的，但是由于它的关键字特性，无法被覆盖，没有其他版本，所以虽然它是非虚方法，但是它的类型是可以确定的。

    解析调用一定是个静态的过程，在编译期就可以完全确定类型，在类加载的解析阶段就可以将符号引用转为直接引用。  而分派调用则可能是静态的或者动态的，根据分派依据的宗量数可以分为单分派或者多分派，由此可以构成静态单分派，静态多分派，动态单分派，动态多分派。 下面就来了解一下分派。



### 2:分派：

重写和重载的原理就是基于分派的，具体来说，重载基于静态分派，重写基于动态分派。

#### (1)：静态分派

首先来看一段代码:

```java
/*
方法静态分派演示
 */
public class StaticDispatch {
    static abstract class Human{
    }
    static class Man extends Human{
    }
    static class Women extends Human{
    }
    public  void sayHello(Human guy){
        System.out.println("hello,human");
    }
    public  void sayHello(Man guy){
        System.out.println("hello man");
    }
    public  void sayHello(Women guy){
        System.out.println("hello women");
    }
    public static void main(String[] args){
        Human man = new Man();
        Human women = new Women();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(women);
    }
}
/*
运行结果：
hello,human
hello,human
*/
```

通过以上代码的执行可以发现，似乎重载的方法不认传入的变量的实际类型，而只认变量的静态类型， 拿上面代码说明，就是不认实际类型Man,Wo'man,只认时 new对象时左边的引用类型（即静态类型Human）。

代码中定义了两个静态类型相同但是实际类型不同的变量，但是jvm在重载时通过传入参数的静态类型作为判断标准的，并且静态类型是编译期可知的。因此，在编译阶段，javac编译器会根据参数的静态类型不同决定使用哪个重载版本，所以使用了sayHello(Human guy)这个版本，并且把这个方法的符号引用，写入了main方法中的两条invokevitural指令中。

> 所有依赖于静态类型来确定方法调用版本的分派动作都属于静态分派，典型应用就是重载。



### （2）动态分派

它和多态性的一个重要体现“重写”，有着密切的关系，来看下面的例子。

```java
/**
 * 方法动态分派演示
 */
public class DynamicDiapatch {
    static abstract class Human{
        protected abstract void sayHello();
    }
    static class Man extends Human{
        protected void sayHello(){
            System.out.println("man say hello");
        }
    }
    static class Woman extends Human{
        protected void sayHello(){
            System.out.println("woman say hello");
        }    }

    public static void main(String[] args){
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

代码很明确，就是继承重写的关系，而原因类比于上面的重载原理，是由于实际类型的不同，也就是按照实际类型判断的。

Java虚拟机是如何根据实际类型来分派方法的执行版本的呢？这就要从invokevirtual指令的多态查找开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：

①  找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C
②  如果在类型C中找到了与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；如果不通过，则返回java.lang.IllegalAccessError异常。
③  否则，按照继承关系从下往上依次对C的各个父类进行步骤2的搜索和验证过程。
④  如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。
————————————————

由于invokevirtural指令执行的第一步就是在运行期确定接收着的实例类型，所以上面代码中两次调用invokevirtural方法指令都是把常量池中的相关类中方法的符号引用解析到了不同的直接引用上，这个过程就是java重写的本质。

> 把这种在运行期间根据实际类型确定方法执行的版本的分派称为动态分派。



### (3)单分派与多分派

根据分派基于多少种宗量，可以将分派分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

java语言属于静态多分派，动态单分派的语言。



#### (4) jvm动态分派的实现

由于动态分派的执行非常频繁，所以在方法区中，jvm会为类建立一个虚方法表vtable（接口的方法调用也是同理，建立itable）。使用虚方法表的索引来代替元数据提高性能。

虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，则子类的虚方法表中的入口地址和父类相同方法的入口地址是一致的，都指向了父类的实现入口。 如果子类重写了，子类的方法表中将会替换为指向子类实现版本的入口地址。



### 3:动态语言的支持

invokedynamic就是支持动态语言的指令。那么什么是动态语言：它的类型检查在运行期确定而不是在编译期。  而java就是典型的静态语言。

比如javascript就是典型的动态语言，比如 obj.print("xxx") 的调用，不管这个obj是何种类型，只要这种类型的定义中确实包含有这个方法，那么就可以执行成功。

这种差别的产生原因是java语言在编译器间已将print（）方法编译为了完整的符号引用并保存在class文件中，通过这个符号引用，jvm可以翻译为这个方法对应的直接引用。   而js等动态语言中，obj是没有类型的，变量obj的值才具有类型。"变量无类型而变量值有类型"这个特点也是动态语言的一个重要特征。



#### java.lang.invoke包

这个包的主要目的就是除了单纯地依靠符号引用确定类型之外，提供了一种新的动态确定调用方法的机制-------MethodHandle。 它的作用就是让java也可以拥有类似于函数指针或者托方法别名的工具了。 具体看书p261页。

具体来说，就是利用它以后，不会再将方法的分派固化到符号引用中了，即写入class文件中， 而是通过一个具体的方法来实现。

对于动态语言特性来说，还是没有理解Java中的MethodHandle的概念，可以理解为方法句柄，类似于c/c++中的函数指针。   也可以理解为js中的闭包函数。



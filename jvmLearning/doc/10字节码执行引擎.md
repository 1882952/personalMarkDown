## 概述

执行引擎是jvm中最核心的组成部分之一，执行引擎在执行java代码的时候可能会使解释执行（通过解释器将class文件翻译为本地机器能理解的二进制数据流让机器执行），或者可以编译执行（即通过即时编译器产生本地代码直接执行，相当于少了解释器这个中间商，类似于gcc）。

所有java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是结果。



## 一：运行时栈帧结构

栈帧是进行方法调用与执行的数据结构，它是jvm栈中的栈元素，当调用一个方法就会产生一个栈帧，栈帧中存储了局部变量表、操作数栈、动态链接和方法返回地址等信息，这个已经在第二章中了解过了。

在编译代码的时候，栈帧需要多大的局部变量表，需要多深的栈帧都已经确定了，并写入了方法表中的code属性中。

处于栈顶的栈帧被称为当前栈帧，也就是正在被调用的方法对应的栈帧。执行引擎运行的所有字节码指令都只针对于当前栈帧的操作。下面来分析栈帧中的具体内容：

### (1)局部变量表

是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表以变量槽（slot）为最小单位。 可以存放八种数据类型，除了6种基本的数据类型外，还有reference与returnAddress类型。

* reference类型表示一个对象实例的引用，一是从此引用中直接或者间接的查找对象在java堆中数据存放的起始地址索引，二是直接或者间接地查到到对象所属数据类型在方法区中存储的类型信息。

* returnAddress已经很少用了，它代表指向一条字节码指令的地址，原始的jvm使用这个指令进行异常处理，现在已经被异常表所代替。<br>对于64位的数据，比如double，jvm会以高位对齐的方式为其分配两个连续的空间。但是局部变量表创建在线程的堆栈上，属于私有数据，所以不会出现线程安全问题。

> 谨慎注意局部变量表中的slot复用问题，如果slot没有被复用，则jvm会判断原引用仍然在使用，所以就不会gc；
> 
> 局部变量不同与全局变量，比如类变量，可以在准备阶段或者初始化阶段赋初值，而局部变量表不行，必须在它被具体使用前赋初值（赋初值个人理解是相当于给这个变量开辟一个默认的存储空间），否则无法调用。

### （2）操作数栈

操作数栈的作用就是对局部变量表的数据按照调用指令进行相应的处理（将数据压入处理与弹出返回）的区域， 也就是具体进行当前方法代码块执行的工作区。

操作数栈中的元素的数据类型必须与字节码指令严格匹配。 比如int 型数据的加法，就需要iadd指令。

栈帧在设计上是相互独立的，但是经过优化，两栈帧之间可以共享局部变量表的区域。

jvm引擎：基于栈的引擎操作， 这个栈就是栈帧。

### （3）动态链接

每个栈帧都包含一个指向运行池常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用时的动态链接，这个等会再介绍（可以联想多态）。 class文件的常量池中存有大量的符号引用，这些符号引用一部分在类加载阶段或者在第一次使用时转化为直接引用，这种转化称为静态解析。另一部分在每次运行期间转化为直接引用，这部分称为动态链接。

### （4）方法返回地址

当一个方法执行完返回时，只有两种方式，第一种是执行引擎遇到任意一个方法返回的字节码指令，可能有返回值传递给上层的方法调用者。   这种就是通常的返回方式。

第二种是遇到了异常，并且这个异常没有在方法体中得到任何处理，那么方法就会返回。

无论哪种方式，都需要返回到方法被调用的位置。方法的退出过程实际上就相当于栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入到调用者栈帧的操作数栈中，调整pc计数器的值以指向调用指令的后一条指令。



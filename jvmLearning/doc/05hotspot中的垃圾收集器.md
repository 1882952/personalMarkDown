## 复习：

上一篇中学习了垃圾收集中使用的三个算法，以及hotspot是如何进行GC的，今天学习hotspot中的垃圾收集器。



## 一：垃圾收集器

在hotspot中，有七种用于不同分代的垃圾收集器，

![images\垃圾收集器](images\垃圾收集器.png)



此图中，上面是用来回收新生代的垃圾收集器，下面是用来回收老年代的垃圾收集器，如果两个收集器之间存在连线，说明它们可以搭配使用。下面就来简单介绍一下这七种垃圾收集器.

### 1:Serial收集器，应用于新生代

它是一种单线程的收集器，所以在进行垃圾收集时，会暂停掉所有其他的工作线程，对实例应用来说很不友好。

![Serial](images\serial.png)

其过程就和上篇中分析的那样，在安全点gc时，新生代采用复制算法，使用serial实现，暂停所有线程。   

> 虽然它需要gc时停顿所有的工作线程，但是它一般还是运行在单client模式下的新生代收集器的首选，原因就是简单高效。  

### 2：parNew收集器，Serial的多线程版本

它除了多线程收集的特性外，还是许多服务器模式下的首选新生代收集器，与性能无关，它是除了serial之外唯一能和CMS收集器配合的收集器。在cpu日渐多核多线程的情况下，parNew收集器就成了默认的新生代收集器。

![parnew](images\parnew.png)

> 并发与并行：
> 
> 并行：多条线程指令同时执行，可以理解为有多少个核心，就有多少个线程同时执行（不考虑超线程技术）。
> 
> 并发：我们常用的概念，java中的多线程本就原生支持并发，也就是可以在一个cpu中多个线程的相应指令去抢占式执行。

从gc线程和工作线程方面考虑，多条gc线程并行工作，此时用户线程就等待。



### 3：Parallel Scavenge，多线程收集器

- 这个收集器的侧重点是**吞吐量**，即应用程序可执行时间的占比（越大越好）。

- 而parNew 配合CMS是为了追求降低用户的停顿时间，适合交互式使用。

> 吞吐量 = 运行用户代码时间 / \(运行用户代码时间 + 垃圾收集时间\)  
> 
> 追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。

* 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。  
* 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间。  
* 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。



 下面的就是老年代收集器：

### 4：Serial OLd收集器

serial收集器的老年代版本，同理，使用标记整理算法，是单线程的，适合于client模式下的jvm使用。

![serialold](images\serial Old.png)

### 5:Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程和标记整理算法，Parallel Old只能配合Parallel Scavenge使用，侧重于吞吐量。



### 6:CMS:真正意义上的并发收集器

CMS（Courrent Mark sweep）是一款以实现最短回收停顿时间的收集器。适用于服务端，重视响应速度。

它采用的是**标记清理**算法，但是它是并发的，过程如下：

1. 初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。  

2* 并发标记：使用**多条**标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。  

3* 重新标记：Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。  

4* 并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。

其中，初始标记和重新标记这两个过程仍然是要其他工作线程停顿的，因为要进行垃圾回收，那么必须要先标记GC root节点，而roots节点一般是在oopMap中保存着，标记的这个过程不可能是gc线程边标记，这个map中的数据边变化，所以是还是要停顿的。  在初始标记就是找到gc roots，完了以后，并发标记可以再利用这些节点去枚举找到需要回收的对象。   重新标记是为了修正并发标记期间用户程序继续运行时导致标记变动的那一部分对象的标记记录。    最后再并发清除。

> 以上的这个过程可能会不是很明白，我们可以联想一下object的finalize方法，一个对象在回收之前必须至少被标记两次，而这两次标记就是初始标记后的并发标记和重新标记的过程，对象调用finalize方法就是在重新标记之前，所以才可以在finalize方法中自我拯救。

   

 CMS模型图：

![CMS](images\cms.png)



总之，CMS也并不是真正意义上的并发的，它需要在找到GC roots节点的这个过程时还需要停顿其余线程，  对应的操作是初始标记和重新标记这两个标记过程。并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，**总体上说**，CMS 收集器的内存回收过程是与用户线程**一起并发执行**的。

#### CMS中有三个明显的缺点：

- CMS收集器对CPU资源很敏感。CMS默认启动的回收线程数是（CPU数目+3）/4，也就是说当CPU数目大于4个时，并发回收的的线程数不少于四分之一的cpu资源，为了改善这个问题，出现了i-CMS，增量式并发虚拟机，目的就是减少并行操作，转为并发操作。

- 无法处理浮动的垃圾。 因为CMS在并发清理的过程中，用户线程还是在不断运行的，当然也伴随着产生新的垃圾，那么这些垃圾只能等到下一次gc回收，称之为“浮动垃圾”。 如果浮动垃圾产生过多，那么就会触发full GC，即jvm可用空间满了的GC。

- 还有一点就是标记清除算法会产生大量的空间碎片的问题，这这个问题的解决方式是在触发full gc是进行内存碎片的整个操作。可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。

### 7：G1收集器

这是一种新时代的收集器，从开头的图中就可以看出，在新生代与老年代中间，证明了G1收集器可以处理新生代，也可以处理老年代。  它是一款面向服务端应用的垃圾收集器。    顺便提一下，在jdk11中，出现了新的垃圾收集器，ZGC，完全没有分代的概念。

G1具有如下特点：

- 并行与并发：就是cpu核心多了就可以并行操作，cpu核心不足了就优先使用并发操作，充分利用了cpu硬件资源。

- 分代收集：保留了新生代和老年代的概念，但是只用G1就可以完全回收。

- 空间整合：解决了CMS中采用标记清理算法时产生的空间碎片问题，它从整体上看采用了标记整理算法，局部上看又是采用了复制算法，所以不会产生空间碎片问题。

- 可预测的停顿：G1除了降低停顿时间外，还建立了可预测的停顿时间模型。



使用G1收集器时，它将java堆划分为**多个大小相等的独立区域（region）**,虽然还保留新生代和老年代的概念，但是新生代和老年代不用再物理隔离了，它们都是一部分Region的集合。

G1能够创建可预测的时间停顿模型，原因在于G1跟踪各个Region里面的垃圾堆积的价值大小，然后在后台维护一个列表，优先回收价值最大的Region。、

在使用Region后，相当于化整为零，但是呢，各个region区域肯定得相互联系，不然各个Region中的对象就无法相互引用了。在G1中，Region之间的对象引用以及其他收集器中新生代与老年代的引用，jvm都是使用了Remember Set来避免全堆扫描，每个Region都会有一个Remember Set，在jvm对引用类型的数据进行写操作时，会产生一个暂时的中断写操作，然后判断在写引用时，是不是Region里的对象之间有引用，如果是，那么就把这种引用关系保存到对应的Remember Set中。 在GC时，就可以利用Remember Set来判断对象之间的引用关系。



#### G1的过程如下：

1. 初始标记:与CMS第一步一样，只是标记一下GC Roots关联的对象节点。

2. 并发标记：时间较久，但是并发，分析GC root到所有对象的可达性。如果从GC Root节点开始遍历所有对象会比较耗时，实际上JVM也不是这么做的。JVM是使用Remembered Set保存了对象引用的调用信息，在可达性分析的时候只需要同时遍历remembered set就好了，不需要从根节点开始挨个遍历。

3. 最终标记：类似于CMS中重新标记，由于并发标记阶段，用户线程仍然在工作，会对标记产生一些偏差，这时候需要通过remembered set log来记录这些改变，在这个阶段将改变合并到remembered set中。完成最终标记。

4. 筛选清除：通过标记整理的算法，根据用户配置的回收时间，和维护的优先级列表，优先收集价值最大的region。收集阶段是基于标记-整理和复制算法实现。



## 二：理解GC日志

深入理解jvm一书中的P89页，直接看就行。



## 三：总结：

今天主要学习了hotspot中的七种垃圾收集算法（1.7版本），具体分为新生代的收集器 3种 和老年代的收集器 3 种  ， 以及基于新理论的垃圾收集器 G1.

其中主要认识Parnew收集器 （新生代） ，重点掌握CMS（老年代）并发收集器，熟悉其特性，比如只有在初始标记和重新标记时，它才会停顿线程。 认识其三个缺点，比如jvm中明明已经有GC策略了，为什么会出现Full gc，这是一道常见的面试题，

答案是因为CMS采用了标记清理算法，会产生浮动垃圾，当浮动垃圾过多，就会触发Full GC。

还有就是对G1，新时代的收集器的理解，比较其与CMS的区别。













































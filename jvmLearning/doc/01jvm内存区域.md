
一：jvm内存的大致结构：
-----------------
  
   jvm的构成，分为五个部分：程序计数器，java虚拟机栈，本地方法栈，堆，方法区五个
  部分，图形如下：  
  
 ![jvm-memory-structure.jpg](https://github.com/1882952/personalMarkDown/blob/master/jvmLearning/images/jvm-memory-structure.jpg)
  ![](/doc/images/jvm-memory-structure.jpg)
  
  可以发现，没有了方法区，因为在日渐使用动态生成代码的今天，永久代即方法区越来越容易造成OOM，所以，在jdk1.8之后，将方法
  区替换为了元数据区域，元数据空间并不在虚拟机中，而是使用本地内存。
 
 #二：具体分析
   ##（1）程序计数器：
   程序计数器的定义
   
   程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，
   那么此时程序计数器为Undefined。  
  
   程序计数器的作用：  
   * 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
   * 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。
   
   程序计数器的特点
   * 是一块较小的内存空间。
   * 线程私有，每条线程都有自己的程序计数器。
   * 生命周期：随着线程的创建而创建，随着线程的结束而销毁。
   * 是唯一一个不会出现OutOfMemoryError的内存区域。
   
   ##（2）java虚拟机栈：  （每个线程都会开辟一个栈空间）
   
   java虚拟机栈就是java方法的内存模型，每个方法在执行的时候，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、
   方法出口等信息，每一个方法在调用直至完成的过程中，都对应着一个入栈和出栈操作，该方法调用完后，相应的栈帧回收。那么
   这个时候，可以想一下递归，递归过程会对方法不停地调用，每进入方法一次，就创建一个栈帧执行，如果是错误的没有返回条件
   的递归或者递归次数过于多，超过了栈空间栈帧创建数量的阈值，那么就会发生OOM，具体的异常是栈溢出。
   
   那么问题来了,在jvm中，基本的数据类型和java引用在哪保存着呢？其实就是在栈中的_局部变量表_中，下面有张虚拟机栈结构的内存
   图：
   
   
   ![jvm-stack](https://github.com/1882952/personalMarkDown/blob/master/jvmLearning/images/jvm-stack.jpg)
   ![](/doc/images/jvm-stack.jpg)
  
  上图所示的栈结构很清晰，在局部变量表中，存放了编译器可知的各种基本的数据类型、对象引用（可能是指针或者句柄）和returnAddress
  类型（可以简单理解为返回的地址）。其中long与double都会占用两个局部变量表的空间（Slot），其余基本数据
  类型都会只占用一个。注意， <u>局部变量表所需要的内存空间在编译期间就分配好了。</u>
  下面来了解一下压栈出栈过程：
  
  ###入栈出栈：  
  当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。
  
  Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。
  
  方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。
  
  > 由于每个线程的使用都会创建一个栈空间，栈空间的数据时私有的，所以不用考虑同步。
  
  ###java虚拟机栈的OOM判断：
  * 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，
  局部变量表的大小不会发生改变。
  * Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。
    * StackOverFlowError  若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，
    抛出 StackOverFlowError 异常。
    * OutOfMemoryError  若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。
  * Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。
  
  > 出现 StackOverFlowError 时，内存空间可能还有很多，因为可能是栈帧创建的深度超过了阈值。

  ##（3）本地方法栈：用于jvm使用到本地（Native）方法时，比如在java中IO操作就是被封装好的本地方法， 它也是个栈，所以也会OOM
  
  下面简单了解一下就行：
  
  ### 本地方法栈的定义
  
  本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。
  
  ### 栈帧变化过程
  
  本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。
  
  方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。
  
  > 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。

 ##（4）堆：jvm中存放对象的地方，是线程共享区域，需要重点掌握其原理。
 
 ### 堆的定义
 
 堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。但是随着JIT编译器的发展，栈上也可以分配对象等，总之，对象创建
 在堆中并不是那么绝对。  
 
 堆还是垃圾回收的重要区域，又称为“GC”堆，因为GC采用了分代收集算法，所以堆又可以细分为新生代、老年代，也还可以继续细分，
 这里就先简单介绍一下，后面有具体讲GC的分代收集的章节。   -Xmx和-Xms可以设置jvm中堆的内存大小。
 
 > 还有一点需要注意，java堆中也可以分配线程私有的缓冲区，比如ThreadLocal的使用，ThreadLocal具体的原理已经了解过了，复习就行。
 
 ### 堆的特点
 
 * 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
 * 在虚拟机启动时创建。
 * 是垃圾回收的主要场所。
 * 进一步可分为：新生代\(Eden区  From Survior  To Survivor\)、老年代。
 
 不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。
 
 堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。
 
 > Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

##（5）方法区：线程共享的区域，用来存储jvm加载的类信息，常量，静态变量，即使编译后的代码等数据，也比较重要。

### 方法区的特点

* 线程共享。  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
* 永久代。  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
* 内存回收效率低。  方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。
* Java 虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

> 由于永久代的数据不易回收，而且现如今利用反射或者其他技术手段动态生成类的应用越来越普遍，所以更容易发生OOM异常，在1.7版本
中，已经将常量池从方法区中移出，放进了堆空间中， 而在1.8版本后，直接用元数据区域替代了方法区。

###运行时常量池（现已经在堆中）
 class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息，常量池，用于存放编译期生成的各种字面量与符号引用。     
  当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。
  
  而且常量池还有一个特性---动态性，在运行期间，可以向常量池中添加新的常量。如 String 类的 intern\(\) 方法就能在运行期间
  向常量池中添加字符串常量。  不仅是字符串常量，还有基本数据类型对应的包装类，也会将常用的数据量存放入常量池（比如Integer的
  -128----127这一段数据就保存在常量池中）。我们在学习时，为了更好理解，可以这么认为：字符串有字符串常量池，对应的包装类一般
  都是有常量池的。   所以在面试的时候，经常遇到常量池特性的面试题，因此我们应该认清string的不可变和包装类对应的的缓存区间。
  
 ## 直接内存（堆外内存）
 
 直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。

###操作直接内存
  
 比如NIO的模型就是直接操作内存的，它是基于缓冲区和channal通道的IO模式，同步非阻塞，它可以通过调用本地方法直接分配 Java 
 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，
 从而提高了数据操作的效率。
                                                
 >   直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。

  
  ### 直接内存与堆内存比较
  
  * 直接内存申请空间耗费更高的性能
  * 直接内存读取 IO 的性能要优于普通的堆内存。
  * 直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO
  * 堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO
  
  > 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。
  
  #总结：
  今天详细了解了jvm中的五大结构，重点是栈，堆，方法区（现元数据区），下一篇了解Hotspot中对象是如何创建的。
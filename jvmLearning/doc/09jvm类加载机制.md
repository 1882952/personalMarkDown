## 概述

代码的编译从本地机器码转变为字节码，是编程语言发展的一大步。一个类被编译后必须经过jvm加载后才能执行，下面就来了解一下类加载的过程。

## 类加载

### 1：类加载的时机

#### 类的生命周期：

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段：

- 加载

- 验证

- 准备

- 解析

- 初始化

- 使用

- 卸载

其中验证、准备、解析三个步骤可以被概括为类的连接。

![images\loadclass](images\loadclass.png)

加载、验证、准备、初始化和卸载这五个过程是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持java语言的运行时绑定，也称为动态绑定或者晚期绑定，重写方法的调用准确的来说多态就是基于动态绑定的。

#### 什么时候需要进行类的初始化？5种情况，重点掌握

- 遇到new，getstatic，putstatic或者invokestatic这四条指令时，如果类没有进行初始化，就需要类进行初始化。 在实际中的使用场景中：使用new创建对象，读取或者设置一个静态字段（被final修饰的常量已经在编译器加入到常量池除外）的时候，以及调用一个类的静态方法时。

- 使用java.lang.reflect反射包的方法对类进行反射调用的时候，如果类没有进行初始化，就需要类进行初始化。

- 当初始化一个类时，如果其父类没有初始化，就需要先触发其父类的初始化。

- 当jvm启动时，用户要指定一个执行的主类（例如main方法的那个类），就需要触发该类的初始化。

- 当使用动态语言支持的版本时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。



jvm有严格的规定，**有且仅有这个五种情况才会触发初始化**，这五种场景的行为称为对一个类的主动引用。   其余的都是被动引用，不会触发类的初始化。 比如下面的三种情况：

##### (1):通过子类引用父类的静态字段，不会导致子类的初始化。

因为是获取父类的静态字段，相当于对父类执行了getstatic指令，会对父类进行主动引用，而对子类没有主动引用，仅仅是读取了一下子类的属性表，所以只会对父类进行初始化，不会对子类初始化。

```java
/**
 * 被动引用 Demo1:
 * 通过子类引用父类的静态字段，不会导致子类初始化。

 */
class SuperClass {
    static {
        System.out.println("SuperClass init!");
    }

    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

public class NotInitialization {

    public static void main(String[] args) {
        System.out.println(SubClass.value);
        // SuperClass init!
    }

}
```

##### （2）:通过数组来定义引用类,不会触发引用类的初始化。

```java
/**
 * 被动引用 Demo2:
 * 通过数组定义来引用类，不会触发此类的初始化。

 */

public class NotInitialization {

    public static void main(String[] args) {
        SuperClass[] superClasses = new SuperClass[10];
    }

}
```

这段代码不会触发类的初始化，但会触发“[L 全类名”这个类的初始化，它由虚拟机自动生成，直接继承自 java.lang.Object，创建动作由字节码指令 newarray 触发。

##### （3）：常量会在编译期中被存储到常量池中，所以调用常量不会触发类的初始化。

```java
/**
 * 被动引用 Demo3:
 * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

 */
class ConstClass {
    static {
        System.out.println("ConstClass init!");
    }

    public static final String HELLO_BINGO = "Hello Bingo";

}

public class NotInitialization {

    public static void main(String[] args) {
        System.out.println(ConstClass.HELLO_BINGO);
    }

}
```



编译通过之后，常量存储到 NotInitialization 类的常量池中，NotInitialization 的 Class 文件中并没有 ConstClass 类的符号引用入口，这两个类在编译成 Class 之后就没有任何联系了。

### 接口的加载过程

接口的加载过程与类的加载过程稍微有点不同， 接口也有初始化过程，但是它不能像类一样调用static代码块完成类的初始化，但是编译器仍然会为接口生成"<clinit>()"类构造器，用于初始化接口中所定义的成员变量。

接口与类初始化不同的地方在于第三点: 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。



## 2:类加载的过程

下面就来具体分析一下类加载的过程。

#### 2.1：加载

加载是类加载的第一个过程，在加载阶段，jvm需要完成以下三件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。

2. 将这个字节流所代表的静态存储结构转化为方法区中的运行时的数据结构。

3. 在内存中生成该类的class对象（唯一），作为方法区这个类的数据结构的访问入口。



jvm的这三点要求并不算具体，比如“通过一个类的全限定名来获取定义此类的二进制字节流。”，它没有明确地指出必须要在一个class文件中获取，准确地说没有从哪里获取，所以就有了很大的自定义空间，比如利用反射生成的动态代理对象，在jvm运行期间仍然可以生产符合要求的class二进制字节流，然后可以被加载。以下是几种利用了这个特点所发展起来的技术：

- 从 zip 包中读取，如 jar、war等
- 从网络中获取，如 Applet
- 通过动态代理技术生成代理类的二进制字节流
- 由 JSP 文件生成对应的 Class 类
- 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

所以对于一个非数组类（加载过程中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段的这种不强制要求性，既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器完成。  开发人员可以通过自定义的类加载去控制字节流的获取方式（即重写一个类加载器的loadClass方法）。



但是对于数组类而言，数组本身不通过类加载器创建，它是由jvm直接构建的。但是数组类与类加载器仍然有着很密切的关系，因为它的元素最终还是要通过类加载器构建的。



#### 2.2验证

验证是连接阶段的第一步，这一步的目的是为了确保class文件的字节流中包含的信息符合虚拟机的要求，并且不会危害jvm自身的安全。

这一步的操作是验证class的文件格式、元数据验证、字节码验证，符号引用验证。

- 文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
  - 是否以魔数 0XCAFEBABE 开头
  - 主次版本号是否在当前虚拟机处理范围内
  - 常量池是否有不被支持的常量类型
  - 指向常量的索引值是否指向了不存在的常量
  - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据
  - ......
- 元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。
- 字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。
- 符号引用验证 本阶段发生在解析阶段，确保解析正常执行。

#### 2.3准备

准备阶段是正式为**类变量分配内存并且设置类变量初始值的阶段**，这些变量所使用的内存都将在方法区中分配。 记住，仅仅是赋类的静态字段的初始值。

```java
class A{
    private static int a=1;
    private static String a="aaa";
}
```

> 所以类的字段中所有的静态字段的赋值都是在准备阶段赋初始值，比如上面的变量a，初始值为0.  而把a赋值为1的putstatic指令是在程序被编译后，存放于类构造器<client>方法之中的，所以把a赋值为1的动作是在初始化阶段中产生的。

注意常量的赋值是在编译阶段进行的，放在了class文件的常量池中。



#### 2.4：解析

解析阶段是jvm中将符号引用替换为直接引用的过程。

那么符号引用和直接引用又是什么关系呢？

- 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标就行。

- 直接引用：可以直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。

说白了，符号引用就是用来保存class文件中具体的引用关系的，而直接引用就是在准备运行前将符号引用翻译为真实直接的指针，可以指向相应的目标准备等待指令调用运行。

jvm并没有规定解析发生的时间，只要求在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic等16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。

简单来讲，举个例子， 字段 private static String s=“ssss”。  解析阶段做的工作是解析这个 s =  ，将其变为直接引用， 这属于字段解析。



解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析。



#### 2.5:初始化 ，重点掌握

类初始化阶段是类加载的最后一步，也是最重要的一步。到了初始化阶段，才真正地开始执行字节码。

在准备阶段，静态变量已经赋过一次系统要求的初始值了。而在初始化阶段，是执行类构造器<client>（）方法的过程。

下面就来具体了解一下<client>():

- <client>()方法是由编译器自动收集类中所有变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。  在类的初始化时期就可以调用完毕。但是必须注意这么一点，static代码块只能访问到代码块前的静态字段，如下所示：

```java
public class ClinitTest {
    static{
         i=0;
        System.out.println(i); //提示非法的向前引用,因为静态字段定义在后面了

    }
    static int i=1; 

}

```

- <client>方法与类的构造函数（或者说实例构造器<init>（）方法 ： {  }代码块）不同，它不需要显示地调用父类的构造器，虚拟机会保证在子类的<clinit>方法执行前，父类的<clinit>方法已经执行完毕了。所以，**在jvm中第一个被执行的<clinit>方法的类肯定是java.lang.Object**。

- 由于父类的<client>方法先执行，所以父类的静态语句块肯定也是先执行，所以它要优于子类的变量赋值操作。如下：

```java
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
    System.out.println(Sub.B); // 输出 2,而不是输出1

}
```

- <client>（）方法对于类或者接口来说非必须的，如果一个类中没有静态的代码块，也就没有对变量的赋值操作，编译器也不会为这个类生成<client>()方法。    

- 接口之中不能使用静态语句块，但仍然有变量的初始化赋值操作，比如在接口中也是可以定义int a=1的，但是需要注意必须赋初值，而且只能定义抽象方法，static代码块也不能定义。接口中不能使用静态代码块，但接口也需要通过 <clinit>() 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 <clinit>() 方法不需要先执行父类的 <clinit>() 方法，只有当父接口中定义的变量使用时，父接口才会初始化。

- <client>()是在加载阶段调用实现的，所以这个方法在多线程环境下是线程安全的，同步与加锁（锁的class对象）。如果多个线程去同时初始化同一个类，只有一个线程能持有class对象去执行这个类的<client>()方法。  利用这个特性，我们就可以使用静态内部类中定义静态字段生成对象去实现单例。

> 注意，同一个类加载器下，一个类型只会初始化一次，即clinit方法只会调用一次,      类的构造方法{  } 代码块同样也只会在第一次生成对象前调用（相当于init方法）。



到这里，类加载的阶段就介绍完了，然后就是具体使用了，也就是执行main方法中的具体代码。

### 3:类加载器

jvm把类加载阶段中的"通过一个类的全限定名来获取描述此二进制文件的字节流"这个动作放在了jvm外部去实现，以便以让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模板称为“类加载器”。 通过这个特性，使得java在诸多领域获得成功，比如OSGi（开放服务网关协议）、热部署、代码加密等

#### 3.1类与类加载器

##### 判断类是否“相等”

任意一个类，都由**加载它的类加载器**和这个**类本身**一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。

因此，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。

这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。

> 判断两个类是否相等，必须在同一个类加载器下判断，否则即使类相同也会返回false。

#### 3.2双亲委派模型

从jvm的角度来说，只存在两种不同的类加载器：一种是启动类加载器（BootStrap Classloader），用C++实现，是jvm自身的一部分。另一种就是所有其他的类加载器，这些类加载都是由java语言实现，独立于jvm外。

从java程序员的角度来看，可以细分为下面的三类类加载器：

- 启动类加载器（Bootstrap ClassLoader）： 负责将存放在  `<JAVA_HOME>\lib`  目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用，用户在编写自定义的类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

```java
@CallerSensitive
    public ClassLoader getClassLoader() {
        ClassLoader cl = getClassLoader0();
        if (cl == null)
            return null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
        }
        return cl;
    }
    //也就是说，启动类加载器不参与java程序的直接引用，只管将相应区域的类库加载到内存中。
```

- 扩展类加载器（Extension ClassLoader）： 负责加载  `<JAVA_HOME>\lib\ext`  目录中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

![images\classloader](images\classloader.png)

    

#### 双亲委派模型

双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）

### 工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。

在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程。

#### 使用双亲委派好处

java类随着它的类加载器一起具备了一种带有优先级的层次关系，例如Object，这些存放在 rt.jar 中的类，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。

相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在 classpath 下，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证。

所以简单描述一下，使用双亲委派模型的好处是构建一个体系化结构，就如Object类，所有的对象都是属于Object对象。没有双亲委派模型就无法维持这个体系。类比于继承体系但是并类加载器不是继承关系，父类加载器也可以得到复用，只有当父类加载器无法加载完成时才会调用子类的加载器加载。



## 总结：

今天主要学习了类加载的过程与类加载器的结构， 对于类加载过程中的加载、验证、准备、解析、初始化这五个步骤的作用是什么要掌握，需要重点掌握的是，触发类初始化的五种情况，class对象在加载阶段生成，类加载器作用在加载阶段可以自定义（jvm将类加载器加载class的二进制字节流的过程独立于jvm之外）， 准备（初始化类变量（赋默认类型的值））、解析（将符号引用转为直接引用）、初始化（调用<clinit>()方法，具体指的是给静态字段赋值与执行static代码块，初始化是重点）。

了解类加载器，即启动类加载器（只关注将库加载到内存操作）、扩展类加载器（开发者可以直接使用）、应用类加载器（默认类加载器）的关系与作用。

掌握双亲委派模型的结构，需要注意，双亲委派模型中的父子类加载器的关系与启动类加载器无关，即父类加载器最高至扩展类加载器，  自定义的类加载载应用类加载器的下一层， 工作流程是，当一个类需要加载时，可以让父类加载器先尝试加载，如果无法加载，那么就再让自定义的子类加载器加载。  这样的好处是，让父类加载器能够复用，而且尽量保证大多数类是由同一个类加载器加载的，无论使用哪个类加载器加载，最终都会委派给最顶端的启动类加载器加载，从而使得不同加载器加载的 Object 类都是同一个。维系了java中的体系结构。

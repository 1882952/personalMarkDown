# JVM 案例分析

## 一：高性能硬件上的程序部署策略

在高性能硬件上部署程序，目前主要有两种方式：    

* 通过 64 位 JDK 来使用大内存；  
* 使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源。

### 使用 64 位 JDK 管理大内存

堆内存变大后，虽然垃圾收集的频率减少了，但每次垃圾回收的时间变长。 如果堆内存为14 G，那么每次 Full GC 将长达数十秒。如果 Full GC 频繁发生，那么对于一个网站来说是无法忍受的。  

对于用户交互性强、对停顿时间敏感的系统，可以给 Java 虚拟机分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，至少要低到不会影响用户使用。  

可能面临的问题：    

* 内存回收导致的长时间停顿；  
* 现阶段，64位 JDK 的性能普遍比 32 位 JDK 低；  
* 需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照（因为要产生超过 10GB 的 Dump 文件），哪怕产生了快照也几乎无法进行分析；  
* 相同程序在 64 位 JDK 消耗的内存一般比 32 位 JDK 大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。  

### 使用 32 位 JVM 建立逻辑集群

在一台物理机器上启动多个应用服务器进程，每个服务器进程分配不同端口， 然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求。  

考虑到在一台物理机器上建立逻辑集群的目的仅仅是为了尽可能利用硬件资源，并不需要关心状态保留、热转移之类的高可用性能需求， 也不需要保证每个虚拟机进程有绝对的均衡负载，因此使用无 Session 复制的亲合式集群是一个不错的选择。 我们仅仅需要保障集群具备亲合性，也就是均衡器按一定的规则算法（一般根据 SessionID 分配） 将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可。  

可能遇到的问题：    

* 尽量避免节点竞争全局资源，如磁盘竞争，各个节点如果同时访问某个磁盘文件的话，很可能导致 IO 异常；  
* 很难高效利用资源池，如连接池，一般都是在节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余；  
* 各个节点受到 32 位的内存限制；  
* 大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，这时候可以考虑把本地缓存改成集中式缓存。

## 二：集群间的同步导致内存溢出

对于集群中保存数据的本地内存副本，允许读操作频繁，但不应当有过于频繁的写操作。

## 三：堆外内存导致溢出错误

在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了。

比如本地内存的溢出，垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “System.gc\(\)”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。

具体看书。p137页

剩下的还有外部命令导致系统运行缓慢，服务器jvm进程崩溃，不恰当的数据结构导致内存过大等都是jvm中可能会出现问题案例等。

具体看出，书上的描述比较详细。



# 谈谈GC调优思路

## 典型回答：

我们在进行GC调优时，从性能角度看，需要关注三个方面**内存占用、延时和吞吐量**，大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。

#### 基本的调优思路可以总结为：

- 理解应用需求和问题，确定调优目标。可将目标简化为，希
  望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。

- 掌握jvm和gc的状态，定位具体问题。比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。

- 选择的GC类型是否符合应用特征，如果是，具体问题表现在哪里，是新生代gc过长还是mixed GC等出现停顿异常。 如果不是，就该考虑换收集器，如CMS，G1都是注重低延迟的垃圾收集器。

- 通过分析确定具体调整的参数或者软硬件配置

- 重复验证调优是否达到目标。



### 知识扩展：从G1角度理解调优

首先，先来整体了解一下 G1 GC 的内部结构和主要机制。
从内存区域的角度，G1 同样存在着年代的概念，但是与我前面介绍的内存结构很不一样，其内部是类似棋盘状的一个个 region 组成，请参考下面的示意图。

![G1](images\G1.png)




region 的大小是一致的，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分2048 个左右、同等大小的 region，这点可以从源heapRegionBounds.hpp中看到。当然这个数字既可以手动调整，G1 也会根据堆大小自动进行调整。



>  在G1的实现中，年龄只是一个逻辑概念。

具体体现在，一部分 region 是作为 Eden，一部分作为Survivor，除了意料之中的 Old region，G1 会将超过 region 50% 大小的对象（在应用中，通常是 byte 或 char 数组）归类为 Humongous 对象，并放置在相应的 region 中。逻辑上，Humongous region 算是老年代的一部分，因为复制这样的大对象是很昂贵的操作，并不适合新生代 GC 的复制算法。



#### region这样设计的副作用：

例如，region 大小和大对象很难保证一致，这会导致空间的浪费。不知道你有没有注意到，示意图中有的区域是 Humongous 颜色，但没有用名称标记，这是为了表示，特别大的对象是可能占用超过一个 region 的。并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况，请参考OpenJDK 社区的讨论。这本质也可以看作是 JVM 的bug，尽管解决办法也非常简单，直接设置较大的 region 大小，参数如下：

```javascript
-XX:G1HeapRegionSize=<N, 例如 16>M
```

从 GC 算法的角度，G1 选择的是复合算法，可以简化理解为：

- 在新生代，G1采用的仍然是并行的复制算法，所以同样会发生stop the world的现象。

- 在老年代中，大部分情况下都是并发标记，而整理（Compact）则是和新生代 GC 时捎带进行，并且不是整体性的整理，而是增量进行的。（比如老年代的CMS就是并发标记的，G1也是并发标记的，仅仅是标记Gc roots对应的OOpMap时停顿一下）。



以前把新生代Gc叫minor GC，老年代GC叫Major GC ，主要是为了区别Full GC。

现在这种叫法已经不准确了，对于G1来说：

- Minor GC 仍然存在，虽然具体过程会有区别，会涉及 Remembered Set 等相关
  
  处理。

- 老年代回收，则是依靠 Mixed GC。并发标记结束后，JVM 就有足够的信息进行垃圾收集，Mixed GC 不仅同时会清理 Eden、Survivor 区域，而且还会清理部分 Old 区域。可以通过设置下面的参数，指定触发阈值，并且设定最多被包含在一次 Mixed GC 中的 region 比例。

```java
–XX:G1MixedGCLiveThresholdPercent
–XX:G1OldCSetRegionThresholdPercent
```





从 G1 内部运行的角度，下面的示意图描述了 G1 正常运行时的状态流转变化，当然，在发生逃逸失败等情况下，就会触发 Full GC。

![images\G1mixedGC](images\G1mixedGC.png)



G1 相关概念非常多，有一个重点就是 Remembered Set，用于记录和维护 region 之间对象的引用关系。为什么需要这么做呢？试想，新生代 GC 是复制算法，也就是说，类似对象从 Eden或者 Survivor 到 to 区域的“移动”，其实是“复制”，本质上是一个新的对象。在这个过程中，需要必须保证老年代到新生代的跨区引用仍然有效。下面的示意图说明了相关设计。

![images\G1RemberSet](images\G1RemberSet.png)



G1 的很多开销都是源自 Remembered Set，例如，它通常约占用 Heap 大小的 20% 或更高，这可是非常可观的比例。并且，我们进行对象复制的时候，因为需要扫描和更改 Card Table 的信息，这个速度影响了复制的速度，进而影响暂停时间。



 G1 行为变化，它们在一定程度上解决了专栏其他讲中提到的部分困扰，如类型卸载不及时的问题。

- 上面提到了 Humongous 对象的分配和回收，这是很多内存问题的来源，Humongousregion 作为老年代的一部分，通常认为它会在并发标记结束后才进行回收，但是在新版 G1中，Humongous 对象回收采取了更加激进的策略。<br>我们知道 G1 记录了老年代 region 间对象引用，Humongous 对象数量有限，所以能够快速的知道是否有老年代对象引用它。如果没有，能够阻止它被回收的唯一可能，就是新生代是否有对象引用了它，但这个信息是可以在 Young GC 时就知道的，所以完全可以在 Young GC 中就进行 Humongous 对象的回收，不用像其他老年代对象那样，等待并发标记结束。

- 在 jdk8u20 以后字符串排重的特性，在垃圾收集过程中，G1 会把新创
  建的字符串对象放入队列中，然后在 Young GC 之后，并发地（不会 STW）将内部数据char 数组，JDK 9 以后是 byte 数组）一致的字符串进行排重，也就是将其引用同一个数组。你可以使用下面参数激活：<br>-XX:+UseStringDeduplication<br>注意，这种排重虽然可以节省不少内存空间，但这种并发操作会占用一些 CPU 资源，也会导致Young GC 稍微变慢。

- 类型卸载是个长期困扰一些 Java 应用的问题,一个类只有当加载它的自定义类加载器被回收后，才能被卸载。元数据区替换了永久代之后有所改善，但还是可能出现问题。在使用G1后，在并发标记阶段结束后，JVM 即进行类型卸载。

- 我们知道老年代对象回收，基本要等待并发标记结束。这意味着，如果并发标记结束不及时，导致堆已满，但老年代空间还没完成回收，就会触发 Full GC，所以触发并发标记的时机很重要。早期的 G1 调优中，通常会设置参数:-XX:InitiatingHeapOccupancyPercent<br>但是很难给出一个普适的数值，往往要根据实际运行结果调整在 JDK 9 之后的 G1 实现中，这种调整需求会少很多，因为 JVM 只会将该参数作为初始值，会
  在运行时进行采样，获取统计数据，然后据此动态调整并发标记启动时机。对应的 JVM 参数：-XX:+G1UseAdaptiveIHOP，默认已经开启：

- 在最新版本中，G1的full GC也是并行进行的了。



### 调优建议：

- 尽量升级到较新的 JDK 版本；

- 掌握 GC 调优信息收集途径。掌握尽量全面、详细、准确的信息，是各种调优的基础，不仅仅是 GC 调优。我们来看看打开 GC 日志，这似乎是很简单的事情，可是你确定真的掌握了吗？

        除了常用的两个选项，<br>

```java
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
```

还有一些非常有用的日志选项，很多特定问题的诊断都是要依赖这些选项：

```java
-XX:+PrintAdaptiveSizePolicy // 打印 G1 Ergonomics 相关信息
```

如果是怀疑出现引用清理不及时的情况，则可以打开下面选项，掌握到底是哪里出现了堆积。

```java
-XX:+PrintReferenceGC
```

另外，建议开启选项下面的选项进行并行引用处理。

```java
-XX:+ParallelRefProcEnabled
```

JDK 9 中 JVM 和 GC 日志机构进行了重构，**PrintGCDetails 已经被标记为废弃，而PrintGCDateStamps 已经被移除，**指定它会导致 JVM无法启动。可以使用下面的命令查询新的配置参数。

```java
java -Xlog:help 
```

### 通用实践理论

- 如果发现 Young GC 非常耗时，这很可能就是因为新生代太大了，我们可以考虑减小新生代的最小比例。

- 如果是 Mixed GC 延迟较长，部分 Old region 会被包含进 Mixed GC，减少一次处理的 region 个数，就是个直接的选择之一。G1OldCSetRegionThresholdPercent 控制其最大值，还可以利用下面参数
  提高 Mixed GC 的个数，当前默认值是 8，Mixed GC 数量增多，意味着每次被包含的 region减少。<br>

```java
-XX:G1MixedGCCountTarget
```



更多内容需要参考G1调优指南。



### 定位 Full GC 发生的原因，有哪些方式？

1. 首先通过printgcdetail 查看fullgc频率以及时长;

2. 通过dump 查看内存中哪些对象多，这些可能是引起fullgc的原因，看是否能优化

3. 如果堆大或者是生产环境，可以开起jmc 飞行一段时间，查看这期间的相关数据来订位问题.



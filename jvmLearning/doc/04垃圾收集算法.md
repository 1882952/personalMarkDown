### 回收方法区

上一篇文章通过四种引用类型分析了堆中需要回收的对象，那么方法区中需不需要回收呢，当然是需要的。方法区（永久代）中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。

永久代主要回收两部分的内容： 废弃常量和无用的类。

##### （1）判定废弃常量

只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 "abc" 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 "abc" 常量，也没有其它地方引用这个字面量，必要的话，"abc"常量会被清理出常量池。

##### （2）无用的类，需要满足以下三种条件：

- 该类中所有的实例已经被回收，也就是java堆中不存在该类的任何实例。

- 加载该类的ClassLoader已经被回收。

- 该类对应的Java.long.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

需要注意的是，在大量使用反射、动态代理、CGLIb等byteCode框架中，动态生成大量的类需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

> 一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。



## 一：垃圾收集算法

学会了如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：



#### 标记-清除算法：

分为标记和清除两个过程，标记的过程，在上一篇的Finalizer线程中已经分析过了，一个对象在被清理之前至少要经过两次标记，然后才会被回收。  至于实现原理，可以简单地从一个数组考虑，数组在删除元素时，可以先把要删除的元素下标找出来标记，然后当标记一定数量的下标后再统一进行删除操作，这样的话，数组删除了n个元素，但是对数组其他元素的位置移动可以只进行了一次搬运操作。 

> 标记-清除算法的缺点：一个是效率问题，另一个就是内存中由于标记清理，内存中会产生大量的不连续的空间，简称碎片空间。



#### 复制收集算法：（新生代）

为了解决效率问题，复制收集算法出现了，它是将可用内存块平均分为了两块。每次只使用一块，当这块内存使用完了之后，就将还在存活的对象复制到另一块内存中去，然后彻底清理这块的内存空间。   但是这种算法的弊端在于内存缩减为了一半，

代价太高。

现代的商业虚拟机都是采用这种收集算法回收新生代，因为新生代的对象存活时间很短，所以并不需要分配1：1的内存空间，而是采用了一个较大的Eden空间和两个较小的survivor空间，每次使用Eden空间和一个survivor空间，每当回收时，将Eden空间和survivor空间中的还存活的对象一次性地复制到另一个survivor中，然后彻底清理Eden和这个survivor。  hotspot的策略是Eden : survivor : survivor的比例为8:1:1.

也就是说每次新生代可用的内存空间占90%（Eden和一个survivor）。那为什么需要两个survivor呢，我用90%Eden与10%的survivor不好嘛？

在实际中，我们无法保证可存活的对象一定不超过10%，但可存活的对象超过10%怎么办，那么，就可以用一个survivor空间作为分配担保的资源，在Eden和该survivor空间向另一个survivor空间复制可存活对象时，如果发现可存活对象超过10%，那么这个survivor中的对象就可以经过分配担保进入到老年代的空间中，这样就不会出现可存活对象超标问题。  所以使用Eden和一个survivor空间作为新生代对象创建的空间的原因就在这里。



#### 标记-整理算法（老年代）

与标记清理算法类型，但是这里在标记对象后，将可存活的对象向一端先移动，然后清理掉可存活对象边界外的内存，这个过程就相当于先整理一下，将可存活的对象放在一起形成一块区域，然后清理掉这个区域外的对象。   这种算法一般用来清理老年代的对象。



### 分代收集算法：

在jvm中，一般把堆分为新生代和老年代，然后利用上面的三种算法分代处理，比如新生代对象创建多，但死的也快，就采用复制算法。 老年代的对象存活率高，没有额外的空间对它进行分配担保，那么就使用标记清理或者标记整理算法，不必使用额外的空间。



## 二：HotSpot的算法实现：

在前几篇文章中，介绍了对象存活判断算法和垃圾收集算法，下面就来了解一下，Hotspot中是怎么实现的：

### 1:枚举根节点

可达式分析算法，从GC root 开始找引用链，可以作为GC root的节点主要有虚拟机栈中引用的对象（在栈帧中的本地变量表保存着）、方法区中静态变量的引用和常量的引用对象（方法区中的引用称为全局性引用），但是现在的很多应用仅仅方法区就有数百兆内容，所欲逐一检查是否有root节点并不现实。



而且可达性分析还需要保证一致性，需要GC停顿，因为不可能出现可达性还在分析对象链而对象却还在不断地变化。这点不满足的话，就没有准确度（这就相当于并发环境下一边添加一边删除的，必须要保证同步，不然结果就出问题）。 所以在jvm中，GC进行时必须停顿所有的线程（'"stop the word"）,即使在号称永不停顿的CMS中，枚举根节点时也是要停顿的。



目前主流的jvm都是使用的准确性GC，当执行系统停顿下来后，并不需要一个不漏的查找到所有的上下文（栈帧保存的本地变量表的引用）和全局引用的位置，在hotSpot中，使用的一组OopMap的数据结构来达到这个目的，在类加载完成的时候，Hotspot就把对象上内什么偏移量上的什么类型的数据计算出来，在JIT编译中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样，GC在扫描时就可以直接扫到了。  看到这，是不是有些明白了， OopMap就可以类比于HashMap，key就是将对象头上的属性（比如偏移量（hashcode），class类型等）通过相应计算设置为key，对象为value。 维系一个可达式的链也可以理解为类似于hashmap用一个拉链法的散列表完成。



### 2：安全点

OopMap可以完成GCroot的枚举，但是为每一条指令都生成oopMap并不现实，所以在jvm中，不是什么时候都可以GC的，jvm中在特定的位置记录下了这些信息（也就是oopMap中的内容），这些特定的位置称为：**安全点**。

只有在安全点上，程序才可以停下来GC。 但是安全点的选定，既不能太少，也不能太多，它是以是否让程序长时间执行的特征为标准设置的。 而长时间运行的特征是指令序列的复用------那就是方法跳转，循环跳转，异常跳转，所以具有这些功能的指令才会设置安全点。



对于安全点，另一个考虑就是如何在gc时让所有的线程都跑到最近的安全点中停顿。

这里有两种方式，抢先式中断与主动式中断。

1. 抢先式中断：不需要相应的线程主动配合，在GC发生时，先把所有的线程全部中断，如果有线程没跑到安全点，就唤醒它让它跑到安全点再次中断，现在几乎没有虚拟机采用这种方式，因为代价太大，线程的唤醒与中断是要消耗资源的。

2. 主动式中断，当GC需要中断线程时，不直接对线程操作，仅就简单地设置一个标志，每个线程执行时都会轮询这个标志，发现中断标志时就在安全点处将自己挂中断起（注意，轮询标志的地方和安全点是重合的）。  
   
   > 这也是Thread,interrupt（）的实现原理，该方法仅仅是设置一个中断标志位，最普遍的做法是让线程判断这个标志位(Thread.interrupted方法)，然后抛出异常使线程停止运行。



### 3：安全区域：

安全点似乎解决了如何进入GC的问题，但是实际情况不一定，安全点仅仅保证了程序执行时可进入gc的安全点，但是程序不执行时呢，比如让线程处于sleep或者Block状态，这时线程就不再执行，无法响应jvm的中断请求。 对于这种情况，就需要安全区域来解决。

安全区域是指在一段代码块中，引用关系不会发生变化，在这个区域的任意地方发生GC都是安全的。  可以把安全区域看作是被扩展的安全点，相对于安全点，安全区域侧重于不变。

在线程执行到安全区域的代码时，将自己标识为安全区域，当jvm执行gc时，不用管安全区域的代码，在线程被唤醒，要离开安全区域时，它会检查系统是否已经完成了枚举根节点（也就是gc过程），否则就会等待到gc完了以后才会离开安全区域继续执行。 这么做的原因也很简单，在gc时，任何相关的线程都必须中断等待。



## 三：总结：

本篇先学习了上一篇遗留下来的一个知识点，方法区中需要回收的数据：废弃常量和无用的类，记住无用的类的满足条件：所有实例已被回收，类加载器已被回收，class对象没有任何地方引用，也没有反射之类的代码引用。



然后学习了今天的主要内容，垃圾收集算法， 对于新生代而言，对象大量产生大量消亡，使用了复制收集算法，分为一个Eden区和两个survivor区，比例8:1，创建两个survivor区域是为了让创建对象使用时的survivor区做一个分配担保区，如果存活对象超标了就将该区域存活的对象加入老年代。     对于老年代而言，对象存活率高，长期存在，所以使用了标记清理和标记整理算法。



最后学习了hotspot的垃圾收集时的策略,  对于GC roots，对作为可以当做root节点的引用（比如栈帧中的引用，全局引用（方法区中的静态变量和常量对象）），利用一个oopMap的数据结构，利用相应的对象头信息计算得key，把这些root节点保存起来。  这样在枚举根节点时，就遍历这个oopMap数据结构就行。

至于在什么时候gc，jvm采用了必须在安全点进行gc的方式，到了安全点，所有线程中断等待（利用的是主动式中断：设置一个中断标志），然后gc线程再枚举oopMap进行可达性分析，回收不可达的对象（在CMS中，只需要在枚举根节点时让线程中断就行）。   

但是安全点是在程序运行时产生的（判断安全点的依据是长时间执行---方法调用，循环，异常等都可以设置安全点）。 那么程序不运行时呢，比如线程调用sleep或者进入阻塞（block），相应的处理策略就是设置安全区域，对于这些一定时间内不执行的代码块，引用是不变的，所以gc会跳过这些安全区域，然后只有等到gc完成时，安全区域的代码才能被唤醒执行。 



通过以上的总结，最重要的就是一点，在jvm中，gc时需要停止一切线程，最少得在遍历oopMap获得GCroot时必须全部停顿，因为不可能是一边删除一边添加，这样的话 gc roots都是不确定的，对于垃圾回收肯定会出问题。








